<!DOCTYPE html>
<html>

<head>
    <title>2 – Lisp, 1, 2, …, ω</title>
    <link rel="stylesheet" type="text/css" href="css/zz_lisp.css">
</head>

<body>

<div class="substrate">
<div class="body">

<h1 id="chapter:lisp1-2-omega"><span class="wrap"><span class="seq">Глава 2.</span><span class="title">Lisp, 1, 2, …, <i>ω</i></span></span></h1>

<p class="noindent"><span class="initial">Ф</span><span class="sc"><span class="c">ункции занимают</span></span> центральное место
в Лиспе, поэтому очевидно, что эффективность их вызовов очень важна.
Неудивительно, что за прошедшее время соответствующие механизмы были изучены
вдоль и поперёк, а исследования по диагонали всё ещё продолжаются. В этой главе
речь пойдёт о различных вариантах понимания функций и их вызовов. Мы поговорим
о том, что называется Lisp<sub>1</sub> и Lisp<sub>2</sub>, а также их различиях, вызываемых
концепцией отдельных пространств имён. Заканчивается глава рассмотрением
рекурсии и способов её реализации с учётом изученных вопросов.</p>

<div class="bigskip"></div>

<p>Среди всевозможных объектов, используемых интерпретатором, функции требуют
особого подхода. Этот базовый тип объектов имеет личный конструктор:
<code><span class="special">lambda</span></code>, и поддерживает как минимум одну операцию: применение функции
к аргументам. Вряд ли можно его описать ещё проще, не сделав совсем бесполезным.
Кстати, именно то, что у функций немного характерных черт, делает их прекрасным
строительным блоком, инкапсулирующим поведение; функция может делать только то,
для чего она запрограммирована. К примеру, с помощью функций можно представлять
объекты, имеющие поля и методы <span class="cite">[<a href="z1_bibliography.html#ar88">AR88</a>]</span>. В Scheme функциями представляется
вообще всё, что только можно представить в виде функции.</p>

<!--\indexC{APVAL}-->
<!--\indexC{EXPR}-->
<!--\indexC{MACRO}-->
<p id="lisp1-2-omega/par:apval">Попытки сделать вызовы функции более эффективными привели
к множеству (часто несовместимых) вариаций языка. Изначально <span class="sc">L<span class="c">isp</span> 1.5</span>
<span class="cite">[<a href="z1_bibliography.html#mae+62">MAE<sup>+</sup>62</a>]</span> не имел
понятия объекта-функции. Реализация была такова, что переменная, функция и
макрос могли одновременно носить одно и то же имя, так как хранились в различных
ячейках (<code><span class="var">APVAL</span></code>, <code><span class="var">EXPR</span></code> и <code><span class="var">MACRO</span></code><a class="footref" href="zz_footnotes.html#foot2.1"><sup>1</sup></a>) списка
свойств соответствующего символа.</p>

<!--\indexCS{lambda}{как ключевое слово}-->
<p>Maclisp выделял именованные функции в отдельную категорию, а его потомок
<span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> (CLtL2) <span class="cite">[<a href="z1_bibliography.html#ste90">Ste90</a>]</span> только недавно получил поддержку функций как
объектов первого класса. В <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> <code><span class="syntax">lambda</span></code> — это ключевое слово
со значением: «Внимание! Дальше идёт определение анонимной функции».
<code><span class="special">lambda</span></code>-формы не имеют возвращаемого значения и могут находиться лишь
в определённых местах: как первый элемент формы вызова или как первый аргумент
специальной формы <code><span class="special">function</span></code>.</p>

<!--\indexR{объекты!первого класса}-->
<!--\indexR{объекты!полноценные}-->
<!--\indexR{первый класс (объектов)}-->
<!--\indexR{первый класс (объектов)|see{полноценные объекты}}-->
<!--\indexR{полноценные объекты}-->
<p>В отличие от них, Scheme с самой первой версии 1975 года имел функциональные
объекты и единое пространство имён, распространяя понятие <em class="term">первого класса</em>
практически на всё. Объекты первого класса (полноценные объекты) могут
приниматься или возвращаться функциями, находиться в списке, массиве, переменной
и т. д. Такой подход широко распространён в классе языков вроде ML, он же будет
использоваться и здесь.</p>


<h2 id="lisp1-2-omega/sect:lisp1"><span class="wrap"><span class="seq">2.1.</span><span class="title">Lisp<sub>1</sub></span></span></h2>

<!--\indexE{Lisp1@\protectLisp<sub>1</sub>}-->
<!--\indexR{Лисп!Lisp1@\protectLisp<sub>1</sub>}-->
<p>В предыдущей главе мы применяли именно такой подход: функции были объектами
(их создавала <code><span class="func">make-function</span></code>); в процессе вычислений мы не различали
функции и аргументы, при вычислении формы аппликации не было никакой разницы
между вычислением элемента на месте <em class="term">функции</em> и вычислением элементов,
находящихся на месте <em class="term">параметров</em>. Давайте ещё раз посмотрим на
интерпретатор из предыдущей главы:</p>

<pre>(<span class="special">define</span> (<span class="func">evaluate</span> <span class="var">e</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>) ...
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ...
        ((<span class="var">lambda</span>) (<span class="func">make-function</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">env</span>))
        (<span class="syntax">else</span> (<span class="func">invoke</span> (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">e</span>) <span class="var">env</span>)
                      (<span class="func">evlis</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span>) )) ) ) )</pre>

<p>Самое важное в нём:</p>

<ol>
  <li><code><span class="special">lambda</span></code> создаёт полноценные объекты — замыкания, —
    которые сохраняют окружение своего определения.</li>

  <li>При применении функции всё вычисляется одинаковым образом:
      с помощью <code><span class="func">evaluate</span></code>;
      <code><span class="func">evlis</span></code> лишь вызывает
      <code><span class="func">evaluate</span></code> для всех элементов списка.</li>
</ol>

<p>Благодаря этим двум качествам Scheme является представителем семейства Lisp<sub>1</sub>.</p>


<h2 id="lisp1-2-omega/sect:lisp2"><span class="wrap"><span class="seq">2.2.</span><span class="title">Lisp<sub>2</sub></span></span></h2>

<!--\indexE{Lisp2@\protectLisp<sub>2</sub>}-->
<!--\indexR{Лисп!Lisp2@\protectLisp<sub>2</sub>}-->
<p>В большинстве программ на Лиспе при вызовах функций первым элементом формы
является имя глобальной функции. Это справедливо и для программ из предыдущей
главы. Мы могли бы сделать данное ограничение частью языка. Это бы не сильно
изменило внешний вид кода, но облегчило бы вычисление форм: для первого элемента
уже не нужна вся мощь <code><span class="func">evaluate</span></code>, достаточно мини-вычислителя, который бы
умел только искать нужную функцию по имени. Для реализации этой идеи изменим
соответствующую часть <code><span class="func">evaluate</span></code>:</p>

<pre>...
(<span class="syntax">else</span> (<span class="func">invoke</span> (<span class="func">lookup</span> (<span class="func">car</span> <span class="var">e</span>) <span class="var">env</span>)
              (<span class="func">evlis</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span>) )) ...</pre>

<!--\indexC{fenv}-->
<!--\indexR{окружение!функциональное}-->
<p>Теперь у нас два разных вычислителя, по одному на каждый случай, где мы можем
встретить переменную: на месте функции или на месте аргумента. Мы можем
по-разному обрабатывать один и тот же идентификатор в зависимости от его
положения. Если функции требуют особого подхода, то логичным будет также
выделить для них особое пространство имён. Очевидно, что легче искать имена
функций в окружении, где нет имён переменных, которые только мешают.
Интерпретатор легко адаптировать для этого случая. Нам понадобится окружение
для функций <code><span class="var">fenv</span></code> и специализированный вычислитель
<code><span class="func">evaluate-application</span></code>, который знает, как обращаться с элементами данного
окружения. Так как теперь у нас два окружения и два вычислителя, то мы назовём
это Lisp<sub>2</sub> <span class="cite">[<a href="z1_bibliography.html#sg93">SG93</a>]</span>.</p>

<!--\indexC{f.evaluate}-->
<pre>(<span class="special">define</span> (<span class="func">f.evaluate</span> <span class="var">e</span> <span class="var">env</span> <span class="var">fenv</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>)
      (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">lookup</span> <span class="var">e</span> <span class="var">env</span>))
            ((<span class="syntax">or</span> (<span class="func">number?</span> <span class="var">e</span>)(<span class="func">string?</span> <span class="var">e</span>)(<span class="func">char?</span> <span class="var">e</span>)
                 (<span class="func">boolean?</span> <span class="var">e</span>)(<span class="func">vector?</span> <span class="var">e</span>) )
             <span class="var">e</span> )
            (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Cannot <span class="func">evaluate</span>"</span> <span class="var">e</span>)) )
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ((<span class="var">quote</span>)  (<span class="func">cadr</span> <span class="var">e</span>))
        ((<span class="var">if</span>)     (<span class="special">if</span> (<span class="func">f.evaluate</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>)
                      (<span class="func">f.evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>)
                      (<span class="func">f.evaluate</span> (<span class="func">cadddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>) ))
        ((<span class="var">begin</span>)  (<span class="func">f.eprogn</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>))
        ((<span class="var">set!</span>)   (<span class="func">update!</span> (<span class="func">cadr</span> <span class="var">e</span>)
                           <span class="var">env</span>
                           (<span class="func">f.evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>) ))
        ((<span class="var">lambda</span>) (<span class="func">f.make-function</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>))
        (<span class="syntax">else</span>     (<span class="func">evaluate-application</span> (<span class="func">car</span> <span class="var">e</span>)
                                        (<span class="func">f.evlis</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>)
                                        <span class="var">env</span>
                                        <span class="var">fenv</span> )) ) ) )</pre>

<p>За вычисление форм отвечает <code><span class="func">evaluate-application</span></code>, которая принимает
«сырое» имя функции, вычисленные значения аргументов и два текущих окружения.
Как видно из определения <code><span class="special">lambda</span></code>, при создании функции замыкаются оба
окружения: <code><span class="var">env</span></code> и <code><span class="var">fenv</span></code>. В остальном новая версия отличается только тем,
что за <code><span class="var">env</span></code> следует (как тень) <code><span class="var">fenv</span></code>. Естественно, ещё необходимо
доработать функции <code><span class="func">evlis</span></code> и <code><span class="func">eprogn</span></code>, чтобы они использовали <code><span class="var">fenv</span></code>:</p>

<!--\indexC{f.evlis}-->
<!--\indexC{f.eprogn}-->
<pre>(<span class="special">define</span> (<span class="func">f.evlis</span> <span class="var">exps</span> <span class="var">env</span> <span class="var">fenv</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">exps</span>)
      (<span class="func">cons</span> (<span class="func">f.evaluate</span> (<span class="func">car</span> <span class="var">exps</span>) <span class="var">env</span> <span class="var">fenv</span>)
            (<span class="func">f.evlis</span> (<span class="func">cdr</span> <span class="var">exps</span>) <span class="var">env</span> <span class="var">fenv</span>) )
      <span class="hash">'()</span> ) )

(<span class="special">define</span> (<span class="func">f.eprogn</span> <span class="var">exps</span> <span class="var">env</span> <span class="var">fenv</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">exps</span>)
    (<span class="special">if</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">exps</span>))
        (<span class="special">begin</span> (<span class="func">f.evaluate</span> (<span class="func">car</span> <span class="var">exps</span>) <span class="var">env</span> <span class="var">fenv</span>)
               (<span class="func">f.eprogn</span> (<span class="func">cdr</span> <span class="var">exps</span>) <span class="var">env</span> <span class="var">fenv</span>) )
        (<span class="func">f.evaluate</span> (<span class="func">car</span> <span class="var">exps</span>) <span class="var">env</span> <span class="var">fenv</span>) )
    <span class="var">empty-begin</span> ) )</pre>

<p>При вызове функции её аргументы расширяют окружение переменных, для этого
необходимо доработать только способ создания функции; механизм вызова
(<code><span class="func">invoke</span></code>) изменений не требует.</p>

<!--\indexC{f.make-function}-->
<pre>(<span class="special">define</span> (<span class="func">f.make-function</span> <span class="var">variables</span> <span class="var">body</span> <span class="var">env</span> <span class="var">fenv</span>)
  (<span class="special">lambda</span> (<span class="var">values</span>)
    (<span class="func">f.eprogn</span> <span class="var">body</span> (<span class="func">extend</span> <span class="var">env</span> <span class="var">variables</span> <span class="var">values</span>) <span class="var">fenv</span>) ) )</pre>

<p>Задача <code><span class="func">evaluate-application</span></code> в том, чтобы проанализировать функциональный
элемент формы и обеспечить правильный вызов. Если мы последуем путём
<span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>, то на месте функционального элемента может стоять или символ,
или <code><span class="special">lambda</span></code>-форма.</p>

<!--\indexC{evaluate-application}-->
<pre id="lisp1-2-omega/lisp2/src:erroneous-eval-application">(<span class="special">define</span> (<span class="func">evaluate-application</span> <span class="var">fn</span> <span class="var">args</span> <span class="var">env</span> <span class="var">fenv</span>)
  (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">fn</span>)
         (<span class="func">invoke</span> (<span class="func">lookup</span> <span class="var">fn</span> <span class="var">fenv</span>) <span class="var">args</span>) )
        ((<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">fn</span>) (<span class="func">eq?</span> (<span class="func">car</span> <span class="var">fn</span>) '<span class="var">lambda</span>))
         (<span class="func">f.eprogn</span> (<span class="func">cddr</span> <span class="var">fn</span>)
                   (<span class="func">extend</span> <span class="var">env</span> (<span class="func">cadr</span> <span class="var">fn</span>) <span class="var">args</span>)
                   <span class="var">fenv</span> ) )
        (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Incorrect functional term"</span> <span class="var">fn</span>)) ) )</pre>

<p>И что же мы в итоге получили, а что потеряли? Первое очевидное преимущество
состоит в том, что для поиска функции по имени необходим только простой вызов
<code><span class="func">lookup</span></code>, а не <code><span class="func">f.evaluate</span></code> с последующим долгим синтаксическим разбором.
Далее, так как мы избавились ото всех ссылок на переменные в <code><span class="var">fenv</span></code>, это
окружение стало компактнее, а значит и поиск в нём ускорился. Второе
преимущество состоит в ускорении вычисления форм, где на месте функции находится
<code><span class="special">lambda</span></code>-форма. Например:</p>

<pre>(<span class="syntax">let</span> ((<span class="var">state-tax</span> <span class="num">1</span>.<span class="num">186</span>))
  ((<span class="special">lambda</span> (<span class="var">x</span>) (<span class="func">*</span> <span class="var">state-tax</span> <span class="var">x</span>)) (<span class="func">read</span>)) )</pre>

<p>В этом случае для <code>(<span class="special">lambda</span> (<span class="var">x</span>) (<span class="func">*</span> <span class="var">state-tax</span> <span class="var">x</span>))</code> не будет создаваться
замыкание, её тело будет вычислено сразу в правильном окружении.</p>

<p>Проблема в том, что эти два преимущества по сути ничего не дают, так как тех же
результатов можно добиться и в Lisp<sub>1</sub> с помощью небольшого предварительного
анализа. Есть только один действительно приятный момент: Lisp<sub>2</sub> чуть-чуть
быстрее, так как мы можем быть уверены в том, что любое имя из <code><span class="var">fenv</span></code> связано
с функцией и ни с чем иным, а значит, проверку на то, что это действительно
функция, надо выполнять лишь один раз: при помещении функции в окружение. И так
как каждое имя должно быть связано с функцией, то все неиспользуемые имена можно
просто связать с <code><span class="func">wrong</span></code>.</p>

<p>Ввиду того, что каждое имя из <code><span class="var">fenv</span></code> связано с функцией, мы можем вообще
избавиться от вызова <code><span class="func">invoke</span></code>, а заодно и от вызова <code><span class="func">procedure?</span></code> внутри.
Это возможно, потому что мы реализуем интерпретатор на Scheme (в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>
формы вроде <code>((<span class="func">lookup</span> <span class="var">fn</span> <span class="var">fenv</span>) <span class="var">args</span>)</code> запрещены). Для этого следует немного
изменить начало <code><span class="func">evaluate-application</span></code>:</p>

<pre>(<span class="special">define</span> (<span class="func">evaluate-application</span> <span class="var">fn</span> <span class="var">args</span> <span class="var">env</span> <span class="var">fenv</span>)
  (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">fn</span>) ((<span class="func">lookup</span> <span class="var">fn</span> <span class="var">fenv</span>) <span class="var">args</span>))
        ... ) )</pre>

<p>В Лиспе функции вызываются так часто, что любой выигрыш времени при вызовах —
это уже хорошо и может сильно повлиять на производительность. Но этот конкретный
выигрыш не так уж и велик: он появляется только для динамически определяемых
функций, тогда как в большинстве случаев вызываемая функция известна статически.</p>

<p>Теперь поговорим о том, что же мы потеряли. А потеряли мы возможность
<em>вычислить</em> применяемую функцию. Рассмотрим выражение
<code>(<span class="special">if</span> <i>условие</i> (<span class="func">+</span> <span class="num">3</span> <span class="num">4</span>) (<span class="func">*</span> <span class="num">3</span> <span class="num">4</span>))</code>.
В Scheme можно легко вынести аргументы <code><span class="num">3</span></code> и <code><span class="num">4</span></code> за скобки:
<code>((<span class="special">if</span> <i>условие</i> <span class="func">+</span> <span class="func">*</span>) <span class="num">3</span> <span class="num">4</span>)</code>. Это просто, понятно и логично.
Фактически, это тождество. Но в Lisp<sub>2</sub> данная программа вызовет ошибку, так как
<code><span class="special">if</span></code>-форма, стоящая на месте функции, — это ни символ,
ни <code><span class="special">lambda</span></code>-форма.</p>


<h3 id="lisp1-2-omega/lisp2/ssect:eval-func-term"><span class="wrap"><span class="seq">2.2.1.</span><span class="title">Вычисляем функции</span></span></h3>

<p>Возможности текущего окружения функций ещё далеки от возможностей окружения
переменных (окружения параметров). В частности, как вы видели, мы не можем
вычислить применяемую функцию. Традиционный трюк, существующий ещё со времён
Maclisp, заключается в том, что если <code><span class="func">evaluate-application</span></code> натыкается на
что-то непонятное, то она передаёт его функции <code><span class="func">f.evaluate</span></code>:</p>

<!--\indexC{evaluate-application}-->
<pre>(<span class="special">define</span> (<span class="func">evaluate-application2</span> <span class="var">fn</span> <span class="var">args</span> <span class="var">env</span> <span class="var">fenv</span>)
  (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">fn</span>)
         ((<span class="func">lookup</span> <span class="var">fn</span> <span class="var">fenv</span>) <span class="var">args</span>) )
        ((<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">fn</span>) (<span class="func">eq?</span> (<span class="func">car</span> <span class="var">fn</span>) '<span class="var">lambda</span>))
         (<span class="func">f.eprogn</span> (<span class="func">cddr</span> <span class="var">fn</span>)
                   (<span class="func">extend</span> <span class="var">env</span> (<span class="func">cadr</span> <span class="var">fn</span>) <span class="var">args</span>)
                   <span class="var">fenv</span> ) )
        <span class="highlight">(<span class="syntax">else</span> (<span class="func">evaluate-application2</span></span>
               <span class="highlight">(<span class="func">f.evaluate</span> <span class="var">fn</span> <span class="var">env</span> <span class="var">fenv</span>) <span class="var">args</span> <span class="var">env</span> <span class="var">fenv</span>))</span> ) )</pre>

<p>Теперь наша проблема решается следующим образом:</p>

<pre>(<span class="special">if</span> <i>условие</i> (<span class="func">+</span> <span class="num">3</span> <span class="num">4</span>) (<span class="func">*</span> <span class="num">3</span> <span class="num">4</span>)) <span class="math"><span class="rel">≡</span></span> ((<span class="special">if</span> <i>условие</i> '<span class="var">+</span> '<span class="var">*</span>) <span class="num">3</span> <span class="num">4</span>)</pre>

<p>Не особо элегантно, так как необходимо писать лишние кавычки, но по крайней
мере это работает. Работает, но, пожалуй, чересчур прилежно; иногда настолько,
что попадает в бесконечный цикл.</p>

<pre>('''''''''''''<span class="num">1789</span> <i>аргументы</i>)</pre>

<p>Выражение <code>'''''''''''''<span class="num">1789</span></code> сначала будет
вычислено тринадцать раз подряд, пока <code><span class="func">evaluate-application2</span></code> не доберётся до
числа 1789, а затем она попадёт в бесконечный цикл, так как 1789 — это
не функция и не символ, а значит, его надо передать в <code><span class="func">f.evaluate</span></code>,
чтобы… получить опять число 1789! Короче говоря, надо тщательнее
следить за тем, что передаётся <code><span class="func">f.evaluate</span></code>. Проблема остаётся даже тогда,
когда мы перепишем интерпретатор следующим образом:</p>

<pre>(<span class="special">define</span> (<span class="func">evaluate-application3</span> <span class="var">fn</span> <span class="var">args</span> <span class="var">env</span> <span class="var">fenv</span>)
  (<span class="syntax">cond</span>
    ((<span class="func">symbol?</span> <span class="var">fn</span>)
     (<span class="syntax">let</span> ((<span class="var">fun</span> (<span class="func">lookup</span> <span class="var">fn</span> <span class="var">fenv</span>)))
       (<span class="special">if</span> <span class="var">fun</span> (<span class="func">fun</span> <span class="var">args</span>)
           (<span class="func">evaluate-application3</span> (<span class="func">lookup</span> <span class="var">fn</span> <span class="var">env</span>) <span class="var">args</span> <span class="var">env</span> <span class="var">fenv</span>) ) ) )
    ... ) )</pre>

<p>В этом случае, если символ отсутствует в функциональном окружении, то поиск
повторяется уже в окружении переменных. Ой! Даже если предположить, что
не существует функции <code><span class="func">foo</span></code>, мы спокойно можем зациклиться при вычислении
значения переменной. Например:</p>

<pre>(<span class="syntax">let</span> ((<span class="var">foo</span> '<span class="var">foo</span>))
  (<span class="func">foo</span> <i>аргументы</i>) )</pre>

<p>Нет, можно, конечно, встроить в <code><span class="func">evaluate-application</span></code> защиту от этого,
проверяя, совпадает ли значение переменной с её именем. Но ведь можно написать
и так:</p>

<pre>(<span class="syntax">let</span> ((<span class="var">flip</span> '<span class="var">flop</span>)
      (<span class="var">flop</span> '<span class="var">flip</span>) )
  (<span class="func">flip</span>) )</pre>

<p>Единственный вариант, который пока не удалось одурачить — это <a href="#lisp1-2-omega/lisp2/src:erroneous-eval-application">самый первый</a>, поэтому
необходимо найти другой метод вычисления функционального элемента формы.</p>


<h3 id="lisp1-2-omega/lisp2/ssect:duality"><span class="wrap"><span class="seq">2.2.2.</span><span class="title">Двойственность миров</span></span></h3>

<p>Обобщая данные затруднения, можно сказать, что есть некоторые вычисления,
принадлежащие миру параметров, которые мы хотим перенести в мир функций,
и наоборот. Точнее говоря, мы хотим иметь возможность возвращать функцию как
результат вычислений и передавать её как аргумент вычислений.</p>

<!--\indexC{funcall}-->
<p>Если абсолютно необходимо, чтобы на месте функции стояло имя функции, но в то же
время мы хотим иметь возможность вычислять необходимую функцию, то будет
достаточно предопределённой функции, которая знает, как применять функции
к аргументам. Назовём её <code><span class="func">funcall</span></code> (от <em class="term">function call</em>). Она применяет
свой первый аргумент (который обязан быть функцией) к остальным. С её помощью
наша проблема решается следующим образом:</p>

<pre>(<span class="special">if</span> <i>условие</i> (<span class="func">+</span> <span class="num">3</span> <span class="num">4</span>) (<span class="func">*</span> <span class="num">3</span> <span class="num">4</span>)) <span class="math"><span class="rel">≡</span></span> (<span class="func">funcall</span> (<span class="special">if</span> <i>условие</i> <span class="var">+</span> <span class="var">*</span>) <span class="num">3</span> <span class="num">4</span>)</pre>

<p>Все аргументы (первый в том числе) вычисляются обычной <code><span class="func">f.evaluate</span></code>.
Функция <code><span class="func">funcall</span></code> только берёт всё готовое и выполняет вызов. Мы легко можем
определить <code><span class="func">funcall</span></code> как</p>

<!--\indexC{funcall}-->
<pre>(<span class="special">define</span> (<span class="func">funcall</span> . <span class="var">args</span>)
  (<span class="special">if</span> (<span class="func">&gt;</span> (<span class="func">length</span> <span class="var">args</span>) <span class="num">1</span>)
      (<span class="func">invoke</span> (<span class="func">car</span> <span class="var">args</span>) (<span class="func">cdr</span> <span class="var">args</span>))
      (<span class="func">wrong</span> <span class="string">"Incorrect arity"</span> '<span class="var">funcall</span>) ) )</pre>

<p>В Lisp<sub>2</sub> <code><span class="func">funcall</span></code> используется для динамического вычисления функций. Во всех
остальных случаях функция известна и не требуется проверять, действительно ли
это функция.</p>

<p>Обратите внимание на вызов <code><span class="func">invoke</span></code> в <code><span class="func">funcall</span></code>. Эта функция проверяет,
действительно ли её аргумент является функцией, в отличие от
<code><span class="func">evaluate-application</span></code>, где эта проверка не выполняется. Функций <code><span class="func">funcall</span></code>
больше похожа на <code><span class="func">apply</span></code>: обе принимают первым аргументом функцию, а за ним
— необходимые аргументы. Разница между ними лишь в том, что <code><span class="func">funcall</span></code>
статически знает количество передаваемых аргументов.</p>


<!--\indexE{+@<code><span class="func">+</span></code> (в \protect\CommonLisp)}-->
<!--\indexE{*@<code><span class="func">*</span></code> (в \protect\CommonLisp)}-->
<!--\indexE{REPL!определение}-->
<!--\indexR{интерактивная сессия (REPL)}-->
<p>К сожалению, есть ещё одна небольшая проблема. Когда мы пишем <code>(<span class="special">if</span> <i>условие</i> <span class="var">+</span> <span class="var">*</span>)</code>, мы ожидаем получить функцию сложения или умножения. Но то,
что мы сейчас получаем, — это значение переменной <code><span class="var">+</span></code> или <code><span class="var">*</span></code>!
В <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> значения этих переменных и близко не связаны с арифметикой: они
хранят последнее считанное и последнее возвращённое REPL<a class="footref" href="zz_footnotes.html#foot2.tr-1"><sup>*</sup></a> значение!</p>


<!--\indexC{function}-->
<p>Мы ввели <code><span class="func">funcall</span></code> для того, чтобы получить возможность проводить вычисления
с функциями как со значениями. Конечно же, в интерпретаторе присутствует и
обратный процесс: ведь <code><span class="func">evaluate-application</span></code> получает именно такие значения
и вызывает их как функции; но эти преобразования происходят неявно.
В присутствии <code><span class="func">funcall</span></code> нам необходимо иметь возможность явно превратить имя
функциональной переменной <code><span class="var">+</span></code> в соответствующую функцию из окружения функций.
Для этого мы введём ещё одно приспособление: <code><span class="special">function</span></code>. Эта специальная
форма принимает имя функции и возвращает соответствующее функциональное
значение. Теперь мы можем свободно перемещаться меж двух миров:</p>

<pre>(<span class="special">if</span> <i>условие</i> (<span class="func">+</span> <span class="num">3</span> <span class="num">4</span>) (<span class="func">*</span> <span class="num">3</span> <span class="num">4</span>)) <span class="math"><span class="rel">≡</span></span>
       <span class="math"><span class="rel">≡</span></span> (<span class="func">funcall</span> (<span class="special">if</span> <i>условие</i> (<span class="special">function</span> <span class="var">+</span>) (<span class="special">function</span> <span class="var">*</span>)) <span class="num">3</span> <span class="num">4</span>)</pre>

<p>Для определения <code><span class="special">function</span></code> достаточно добавить соответствующую обработку
в <code><span class="func">f.evaluate</span></code>. Эта форма <code><span class="special">function</span></code> не имеет ничего общего с одноимённой
<span class="see">[см. раздел <a href="ch01_basics.html#basics/repr-func/dyn-and-lex-bind/src:closure-eval">1.6.1</a>]</span>
формой <code>(<span class="special">function</span> (<span class="syntax">lambda</span> <i>переменные</i> <i>тело</i>))</code>, создающей замыкания. Здесь
мы определяем <code>(<span class="special">function</span> <i>имя-функции</i>)</code>,
преобразующую имена функций в их значения.</p>

<pre>...
((<span class="var">function)</span>
 (<span class="syntax">cond</span> ((<span class="func">symbol?</span> (<span class="func">cadr</span> <span class="var">e</span>))
        (<span class="func">lookup</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">fenv</span>) )
       (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Incorrect function"</span> (<span class="func">cadr</span> <span class="var">e</span>))) ) ) ...</pre>

<!--\indexCS{lambda}{как метка}-->
<p>Мы легко можем расширить это определение, чтобы оно принимало и
<code><span class="special">lambda</span></code>-формы, как это сделано в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> или у нас в разделе <a href="ch01_basics.html#basics/repr-func/dyn-and-lex-bind/src:closure-eval">1.6.1</a>. Но в этом
нет особого смысла, так как наша <code><span class="special">lambda</span></code> сразу возвращает нужное значение.
В <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> такое расширение необходимо, потому что там <code><span class="syntax">lambda</span></code> лишь
помечает код функции и «специальной форме» <code><span class="syntax">lambda</span></code> позволено или
находиться на месте функции, или быть первым аргументом специальной формы
<code><span class="special">function</span></code>.</p>

<p>Функция <code><span class="func">funcall</span></code> позволяет поместить результат вычислений из мира параметров
в переменную из мира функций. И наоборот, <code><span class="special">function</span></code> позволяет поместить
значение из мира функций в переменную из мира параметров. В них усматриваются
очевидные параллели: «применение функций — <code><span class="func">funcall</span></code>» и «разыменование
переменных — <code><span class="special">function</span></code>». Одновременное существование двух миров и
возможность общения между ними требуют подобных мостов.</p>

<!--\indexR{инлайнинг!функций}-->
<!--\indexR{функции!встраиваемые}-->
<!--\indexR{встраивание!функций}-->
<p>Заметьте, что сейчас мы не имеем возможности изменять функциональное окружение;
у нас нет соответствующего присваивания. Это позволяет компиляторам без опаски
и в полную силу задействовать механизм <em class="term">инлайн-функций</em>. Одной из
привлекательных сторон использования нескольких пространств имён является
возможность наделить каждое из них особыми свойствами.</p>


<h3 id="lisp1-2-omega/lisp2/ssect:using"><span class="wrap"><span class="seq">2.2.3.</span><span class="title">Используем Lisp<sub>2</sub></span></span></h3>

<p>Чтобы полностью определить наш Lisp<sub>2</sub>, остаётся указать начальное функциональное
окружение и запустить в цикле сам интерпретатор, <code><span class="func">f.evaluate</span></code>. Определение
глобального функционального окружения мало чем отличается от окружения
переменных: надо всего лишь расширять другое начальное окружение.</p>

<!--\indexC{fenv.global}-->
<!--\indexC{definitial-function}-->
<!--\indexC{defprimitive}-->
<pre>(<span class="special">define</span> <span class="var">fenv.global</span> <span class="hash">'()</span>)

(<span class="special">define-syntax</span> <span class="var">definitial-function</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">definitial-function</span> <span class="var">name</span>)
     (<span class="special">begin</span> (<span class="special">set!</span> <span class="var">fenv.global</span> (<span class="func">cons</span> (<span class="func">cons</span> '<span class="var">name</span> '<span class="var">void</span>) <span class="var">fenv.global</span>))
            '<span class="var">name</span>) )
    ((<span class="syntax">definitial-function</span> <span class="var">name</span> <span class="var">value</span>)
     (<span class="special">begin</span> (<span class="special">set!</span> <span class="var">fenv.global</span> (<span class="func">cons</span> (<span class="func">cons</span> '<span class="var">name</span> <span class="var">value</span>) <span class="var">fenv.global</span>))
            '<span class="var">name</span>) ) ) )

(<span class="special">define-syntax</span> <span class="var">defprimitive</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">defprimitive</span> <span class="var">name</span> <span class="var">value</span> <span class="var">arity</span>)
     (<span class="syntax">definitial-function</span> <span class="var">name</span>
       (<span class="special">lambda</span> (<span class="var">values</span>)
         (<span class="special">if</span> (<span class="func">=</span> <span class="var">arity</span> (<span class="func">length</span> <span class="var">values</span>))
             (<span class="func">apply</span> <span class="var">value</span> <span class="var">values</span>)
             (<span class="func">wrong</span> <span class="string">"Incorrect arity"</span>
              (<span class="func">list</span> '<span class="var">name</span> '<span class="var">values</span>) ) ) ) ) ) ) )

(<span class="syntax">defprimitive</span> <span class="var">car</span> <span class="var">car</span> <span class="num">1</span>)
(<span class="syntax">defprimitive</span> <span class="var">cons</span> <span class="var">cons</span> <span class="num">2</span>)</pre>

<p class="noindent">И наконец:</p>

<pre>(<span class="special">define</span> (<span class="fbox"><i>бесспорно Lisp<sub>2</sub></i></span>)
  (<span class="special">define</span> (<span class="func">toplevel</span>)
    (<span class="func">display</span> (<span class="func">f.evaluate</span> (<span class="func">read</span>) <span class="var">env.global</span> <span class="var">fenv.global</span>))
    (<span class="func">toplevel</span>) )
  (<span class="func">toplevel</span>) )</pre>


<h3 id="lisp1-2-omega/lisp2/ssect:enriching"><span class="wrap"><span class="seq">2.2.4.</span><span class="title">Расширяем функциональное окружение</span></span></h3>

<!--\indexR{окружение!как тип данных}-->
<p>Все окружения — это объекты некоторого абстрактного типа данных. Что мы
ожидаем от этого типа данных? Мы ожидаем, что он будет хранить связи между
именами и сущностями, что мы можем по имени отыскать нужную сущность, и что мы
можем добавлять новые связи. Ещё мы хотим иметь возможность определять локальные
функции, а для этого необходим механизм локального расширения функционального
окружения. В общем, хочется <code><span class="syntax">let</span></code>, но только для функций. Сейчас
функциональное окружение неизменяемо, так что было бы здорово иметь такую
возможность. Создадим новую специальную форму <code><span class="special">flet</span></code> (<em class="term">functional let</em>)
со следующим синтаксисом:</p>

<!--\indexC{flet}-->
<pre>(<span class="special">flet</span> ((<i>имя<sub>1</sub></i> <i>аргументы<sub>1</sub></i> <i>тело<sub>1</sub></i>)
        ...
       (<i>имя<sub>n</sub></i> <i>аргументы<sub>n</sub></i> <i>тело<sub>n</sub></i>) )
  <i>выражения</i>... )</pre>

<p>Так как <code><span class="special">flet</span></code> умеет создавать только локальные функции, нет необходимости
писать <code><span class="special">lambda</span></code>, это и так подразумевается. Специальная форма <code><span class="special">flet</span></code>
вычисляет формы <code>(<span class="special">lambda</span> <i>аргументы<sub>i</sub></i> <i>тело<sub>i</sub></i>)</code> и связывает
получаемые значения с именами <i>имя<sub>i</sub></i> в функциональном окружении. После
этого <i>выражения</i> вычисляются в расширенном окружении, где можно ставить
<i>имя<sub>i</sub></i> на место функции или передавать его в <code><span class="special">function</span></code>, если
понадобится соответствующее замыкание.</p>

<p>Добавить <code><span class="special">flet</span></code> в <code><span class="func">f.evaluate</span></code> просто:</p>

<pre>...
((<span class="var">flet</span>)
 (<span class="func">f.eprogn</span>
  (<span class="func">cddr</span> <span class="var">e</span>)
  <span class="var">env</span>
  (<span class="func">extend</span> <span class="var">fenv</span>
          (<span class="func">map</span> <span class="var">car</span> (<span class="func">cadr</span> <span class="var">e</span>))
          (<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">def</span>)
                 (<span class="func">f.make-function</span> (<span class="func">cadr</span> <span class="var">def</span>) (<span class="func">cddr</span> <span class="var">def</span>) <span class="var">env</span> <span class="var">fenv</span>) )
               (<span class="func">cadr</span> <span class="var">e</span>) ) ) ) ) ...</pre>

<p>Форма <code><span class="special">flet</span></code> серьёзно расширяет наши возможности: например, она позволяет
<code><span class="special">lambda</span></code> замыкать в себе не только <code><span class="var">env</span></code>, но и <code><span class="var">fenv</span></code>. Рассмотрим
пример:</p>

<pre>(<span class="special">flet</span> ((<span class="func">square</span> (<span class="var">x</span>) (<span class="func">*</span> <span class="var">x</span> <span class="var">x</span>))
  (<span class="special">lambda</span> (<span class="var">x</span>) (<span class="func">square</span> (<span class="func">square</span> <span class="var">x</span>))) )</pre>

<p>Значением этого выражения является анонимная функция, возводящая число
в четвёртую степень. Это замыкание сохраняет в себе и использует локальную
функцию <code><span class="func">square</span></code>.</p>


<h2 id="lisp1-2-omega/sect:extensions"><span class="wrap"><span class="seq">2.3.</span><span class="title">Другие возможности</span></span></h2>

<p>Как только мы заставили вычислитель относиться по-особенному к функциям, на ум
сразу же приходят другие варианты использования этой возможности. Например, мы
могли бы трактовать числа как функции-аксессоры для списков:</p>

<pre>(<span class="func">2</span> '(<span class="var">foo</span> <span class="var">bar</span> <span class="var">hux</span> <span class="var">wok</span>))  <span class="math"><span class="rel">→</span></span> <span class="var">hux</span>
(<span class="func">-2</span> '(<span class="var">foo</span> <span class="var">bar</span> <span class="var">hux</span> <span class="var">wok</span>)) <span class="math"><span class="rel">→</span></span> (<span class="var">hux</span> <span class="var">wok</span>)</pre>

<p>Число <span class="math"><span class="ord var">n</span></span> считается синонимом для <code><span class="func">cad<span class="math"><sup><span class="ord var">n</span></sup></span>r</span></code>, если оно неотрицательно,
или <code><span class="func">cd<span class="math"><sup><span class="ord">−</span><span class="ord var">n</span></sup></span>r</span></code>, если оно меньше ноля. Базовым аксессорам <code><span class="func">car</span></code> и
<code><span class="func">cdr</span></code> соответствуют числа <code><span class="num">0</span></code> и <code><span class="num">-1</span></code>. После этого элементарно
реализуются чисто алгебраические преобразования <code>(<span class="func">-1</span> (<span class="func">-2</span> <span class="math"><span class="ord var">π</span></span>)) <span class="math"><span class="rel">≡</span></span> (<span class="func">-3</span> <span class="math"><span class="ord var">π</span></span>)</code> или
<code>(<span class="func">2</span> (<span class="func">-3</span> <span class="math"><span class="ord var">π</span></span>)) <span class="math"><span class="rel">≡</span></span> (<span class="func">5</span> <span class="math"><span class="ord var">π</span></span>)</code>.</p>

<p>Также можно придать смысл спискам функций на месте функции:</p>

<pre>((<span class="func">list</span> <span class="var">+</span> <span class="var">-</span> <span class="var">*</span>) <span class="num">5</span> <span class="num">3</span>) <span class="math"><span class="rel">→</span></span> (<span class="num">8</span> <span class="num">2</span> <span class="num">15</span>)</pre>

<p>Применение списка функций возвращает список из результатов применения каждого
элемента-функции к соответствующим аргументам. Фактически, предыдущий пример
— это краткая запись для</p>

<pre>(<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">f</span>) (<span class="func">f</span> <span class="num">5</span> <span class="num">3</span>))
     (<span class="func">list</span> <span class="var">+</span> <span class="var">-</span> <span class="var">*</span>) )</pre>

<p>Наконец, мы могли бы разрешить функции быть вторым элементом аппликации,
эмулируя привычную инфиксную запись: выражение <code>(<span class="num">1</span> <span class="func">+</span> <span class="num">2</span>)</code> вернёт <code><span class="num">3</span></code>.
К примеру, такое поведение реализовано в DWIM из <span class="cite">[<a href="z1_bibliography.html#tei74">Tei74</a>, <a href="z1_bibliography.html#tei76">Tei76</a>]</span>.</p>

<p>Но, во-первых, подобные инновации опасны, так как они уменьшают количество явно
ошибочных форм, а значит, затрудняют поиск ошибок, которые иначе бы легко
находились. Во-вторых, они не дают какой-либо существенной экономии и в конце
концов редко используются. В-третьих, они ещё сильнее разделяют функции и
функциональные объекты, которые можно применять как функции. Списки или числа
становятся вызываемыми, но вовсе не обязуются быть функциями. В итоге становятся
возможными безобразия вроде</p>

<pre>(<span class="func">apply</span> (<span class="func">list</span> <span class="num">2</span> (<span class="func">list</span> <span class="num">0</span> (<span class="func">+</span> <span class="num">1</span> <span class="num">2</span>)))
       '(<span class="var">foo</span> <span class="var">bar</span> <span class="var">hux</span> <span class="var">wok</span>) )
   <span class="math"><span class="rel">→</span></span> (<span class="func">hux</span> (<span class="func">foo</span> <span class="var">wok</span>))</pre>

<p>Поэтому не рекомендуется реализовывать данные инновации как часть базового языка.
<span class="see">[см. упр. <a href="#lisp1-2-omega/ex:innovations">2.3</a>]</span></p>


<h2 id="lisp1-2-omega/sect:comparison"><span class="wrap"><span class="seq">2.4.</span><span class="title">Сравнение Lisp<sub>1</sub> и Lisp<sub>2</sub></span></span></h2>

<p>Подходя к окончанию наших исследований Lisp<sub>1</sub> и Lisp<sub>2</sub>, что мы можем сказать
в итоге об этих двух подходах?</p>

<!--\indexR{пространства имён}-->
<!--\indexE{Lispn@\protect\Lisp{\protect\ii{n}}}-->
<!--\indexR{Лисп!Lispn@\protect\Lisp{\protect\ii{n}}}-->
<p>Scheme является Lisp<sub>1</sub>, на нём приятно программировать и ему легко обучать, так
как процесс вычислений прост и последователен. Lisp<sub>2</sub> же более сложен, потому
что существование двух миров требует использования особых форм для перехода
между ними. <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> является не совсем Lisp<sub>2</sub>, так как имеет множество
других пространств имён: для меток лексических переходов, для меток форм
<code><span class="special">tagbody</span></code> и т. д. Поэтому иногда его называют Lisp<sub><i>n</i></sub>, так как одно и
то же имя может вести себя различными способами в зависимости от синтаксической
роли. Языки со строгим синтаксисом (или, как говорят, с деспотичным синтаксисом)
часто имеют множество пространств имён или множество окружений (для переменных,
для функций, для типов и т. д.). Каждое из этих окружений имеет свои
особенности. Например, если функциональное окружение неизменяемо (то есть
функциям нельзя присваивать новые значения), то становится очень легко
оптимизировать вызовы локальных функций.</p>

<p>В программах на Lisp<sub>2</sub> функции чётко отделены от остальных вычислений. Это очень
выгодное разграничение, так что, по мнению <span class="cite">[<a href="z1_bibliography.html#sen89">Sén89</a>]</span>, его следует применять
всем хорошим компиляторам Scheme. Внутри них программы переводятся на
Lisp<sub>2</sub>-язык, который удаётся лучше компилировать. Компилятор чётко определяет
каждое место, куда необходимо вставить <code><span class="func">funcall</span></code>, — те места, где функции
вычисляются динамически. Пользователи Lisp<sub>2</sub> вынуждены делать часть работы
компилятора вручную, так что в итоге они лучше понимают стоимость использования
своих конструкций.</p>

<!--\indexE{Lisp2@\protectLisp<sub>2</sub>}-->
<!--\indexR{Лисп!Lisp2@\protectLisp<sub>2</sub>}-->
<p>На предыдущих страницах мы разобрали довольно много вариаций, так что сейчас
будет полезным собрать всё воедино и дать ещё одно определение — простейшее
из возможных — очередного Lisp<sub>2</sub>-языка, похожего на <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>. В этот раз
мы ограничимся только введением функции <code><span class="func">f.lookup</span></code>, которая ищет функцию по
имени в функциональном окружении, а если не находит, то вызывает <code><span class="func">wrong</span></code>. Это
позволит гарантировать конечное время выполнения <code><span class="func">f.lookup</span></code>. Конечно,
следствием такого похода будет появление своеобразных ошибок замедленного
действия, так как само по себе обращение к неопределённой функции не считается
ошибочным. Проблемы возникают лишь при попытке вызова, которая может произойти
гораздо позже, а то и вовсе никогда.</p>

<!--\indexC{f.evaluate}-->
<!--\indexC{f.evaluate-application}-->
<!--\indexC{f.lookup}-->
<pre>(<span class="special">define</span> (<span class="func">f.evaluate</span> <span class="var">e</span> <span class="var">env</span> <span class="var">fenv</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>)
      (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">lookup</span> <span class="var">e</span> <span class="var">env</span>))
            ((<span class="syntax">or</span> (<span class="func">number?</span> <span class="var">e</span>)(<span class="func">string?</span> <span class="var">e</span>)(<span class="func">char?</span> <span class="var">e</span>)
                 (<span class="func">boolean?</span> <span class="var">e</span>)(<span class="func">vector?</span> <span class="var">e</span>) )
             <span class="var">e</span> )
            (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Cannot evaluate"</span> <span class="var">e</span>)) )
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ((<span class="var">quote</span>)  (<span class="func">cadr</span> <span class="var">e</span>))
        ((<span class="var">if</span>)     (<span class="special">if</span> (<span class="func">f.evaluate</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>)
                      (<span class="func">f.evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>)
                      (<span class="func">f.evaluate</span> (<span class="func">cadddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>) ))
        ((<span class="var">begin</span>)  (<span class="func">f.eprogn</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>))
        ((<span class="var">set!</span>)   (<span class="func">update!</span> (<span class="func">cadr</span> <span class="var">e</span>)
                           <span class="var">env</span>
                           (<span class="func">f.evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>) ))
        ((<span class="var">lambda</span>) (<span class="func">f.make-function</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>))
        ((<span class="var">function</span>)
         (<span class="syntax">cond</span> ((<span class="func">symbol?</span> (<span class="func">cadr</span> <span class="var">e</span>))
                (<span class="func">f.lookup</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">fenv</span>) )
               ((<span class="syntax">and</span> (<span class="func">pair?</span> (<span class="func">cadr</span> <span class="var">e</span>)) (<span class="func">eq?</span> (<span class="func">car</span> (<span class="func">cadr</span> <span class="var">e</span>)) '<span class="var">lambda</span>))
                (<span class="func">f.make-function</span>
                 (<span class="func">cadr</span> (<span class="func">cadr</span> <span class="var">e</span>)) (<span class="func">cddr</span> (<span class="func">cadr</span> <span class="var">e</span>)) <span class="var">env</span> <span class="var">fenv</span> ) )
               (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Incorrect function"</span> (<span class="func">cadr</span> <span class="var">e</span>))) ) )
        ((<span class="var">flet</span>)
         (<span class="func">f.progn</span> (<span class="func">cddr</span> <span class="var">e</span>)
                  <span class="var">env</span>
                  (<span class="func">extend</span> <span class="var">fenv</span> (<span class="func">map</span> <span class="var">car</span> (<span class="func">cadr</span> <span class="var">e</span>))
                          (<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">def</span>)
                                 (<span class="func">f.make-function</span> (<span class="func">cadr</span> <span class="var">def</span>)
                                                  (<span class="func">cddr</span> <span class="var">def</span>)
                                                  <span class="var">env</span> <span class="var">fenv</span> ) )
                               (<span class="func">cadr</span> <span class="var">e</span>) ) ) ) )
        ((<span class="var">labels</span>)
         (<span class="syntax">let</span> ((<span class="var">new-fenv</span> (<span class="func">extend</span> <span class="var">fenv</span>
                                 (<span class="func">map</span> <span class="var">car</span> (<span class="func">cadr</span> <span class="var">e</span>))
                                 (<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">def</span>) '<span class="var">void</span>)
                                      (<span class="func">cadr</span> <span class="var">e</span>) ) )))
           (<span class="func">for-each</span> (<span class="special">lambda</span> (<span class="var">def</span>)
                       (<span class="func">update!</span> (<span class="func">car</span> <span class="var">def</span>)
                                <span class="var">new-fenv</span>
                                (<span class="func">f.make-function</span> (<span class="func">cadr</span> <span class="var">def</span>) (<span class="func">cddr</span> <span class="var">def</span>)
                                                 <span class="var">env</span> <span class="var">new-fenv</span> ) ) )
                     (<span class="func">cadr</span> <span class="var">e</span>) )
           (<span class="func">f.eprogn</span> (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">new-fenv</span>) ) )
        (<span class="syntax">else</span> (<span class="func">f.evaluate-application</span> (<span class="func">car</span> <span class="var">e</span>)
                                      (<span class="func">f.evlis</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span>)
                                      <span class="var">env</span>
                                      <span class="var">fenv</span> )) ) ) )

(<span class="special">define</span> (<span class="func">f.evaluate-application</span> <span class="var">fn</span> <span class="var">args</span> <span class="var">env</span> <span class="var">fenv</span>)
  (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">fn</span>)
         ((<span class="func">f.lookup</span> <span class="var">fn</span> <span class="var">fenv</span>) <span class="var">args</span>) )
        ((<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">fn</span>) (<span class="func">eq?</span> (<span class="func">car</span> <span class="var">fn</span>) '<span class="var">lambda</span>))
         (<span class="func">f.eprogn</span> (<span class="func">cddr</span> <span class="var">fn</span>)
                   (<span class="func">extend</span> <span class="var">env</span> (<span class="func">cadr</span> <span class="var">fn</span>) <span class="var">args</span>)
                   <span class="var">fenv</span> ) )
        (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Incorrect functional term"</span> <span class="var">fn</span>)) ) )

(<span class="special">define</span> (<span class="func">f.lookup</span> <span class="var">id</span> <span class="var">fenv</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">fenv</span>)
      (<span class="special">if</span> (<span class="func">eq?</span> (<span class="func">caar</span> <span class="var">fenv</span>) <span class="var">id</span>)
          (<span class="func">cdar</span> <span class="var">fenv</span>)
          (<span class="func">f.lookup</span> <span class="var">id</span> (<span class="func">cdr</span> <span class="var">fenv</span>)) )
      (<span class="special">lambda</span> (<span class="var">values</span>)
        (<span class="func">wrong</span> <span class="string">"No such functional binding"</span> <span class="var">id</span>) ) ) )</pre>

<p>Ещё одно важное, по мнению <span class="cite">[<a href="z1_bibliography.html#gp88">GP88</a>]</span>, практическое различие между Lisp<sub>1</sub> и
Lisp<sub>2</sub> состоит в читабельности. Хотя, конечно, опытные программисты вряд ли
будут писать что-то вроде:</p>

<pre>(<span class="special">defun</span> <span class="func">foo</span> (<span class="var">list</span>)
  (<span class="func">list</span> <span class="var">list</span>) )</pre>

<!--\indexR{самоприменение!в \protectLisp<sub>1</sub> и \protectLisp<sub>2</sub>}-->
<p class="noindent">С точки зрения Lisp<sub>1</sub>, <code>(<span class="func">list</span> <span class="var">list</span>)</code> — это вполне допустимое
самоприменение,<a class="footref" href="zz_footnotes.html#foot2.2"><sup>2</sup></a> но в Lisp<sub>2</sub>
это выражение имеет совершенно различный смысл. В <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> эти два имени
принадлежат различным окружениям и не конфликтуют. Тем не менее, лучше избегать
подобного стиля именования и не называть локальные переменные именами известных
глобальных функций; это поможет избежать проблем с макросами и сделает программы
менее зависимыми от используемого диалекта.</p>


<!--\indexR{макросы!в \protectLisp<sub>1</sub> и \protectLisp<sub>2</sub>}-->
<p>Следующее отличие между Lisp<sub>1</sub> и Lisp<sub>2</sub> заключается в собственно макросах.
В <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> довольно непросто написать макрос, раскрывающийся
в <code><span class="special">lambda</span></code>-форму, который был бы полезен, например, при реализации объектной
системы. Дело в том, что <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> ограничивает места, где может появляться
<code><span class="syntax">lambda</span></code>. Она может стоять только на месте функции, так что конструкция
<code>(... (<span class="syntax">lambda</span> ...) ...)</code> вызовет ошибку в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>. Единственное
исключение — <code><span class="syntax">lambda</span></code> может быть первым аргументом <code><span class="special">function</span></code>. Но сама
<code><span class="special">function</span></code> может быть только параметром функции, так что
<code>((<span class="special">function</span> (<span class="syntax">lambda</span> ...)) ...)</code> — это снова ошибка. Если макрос не знает, где именно он
раскроется: как аргумент или как функция, то его нельзя использовать без
некоторого усложнения программ. Для той же системы объектов, например, придётся
раскрывать макрос в <code>(<span class="special">function</span> (<span class="syntax">lambda</span> ...))</code>, а потом вручную оборачивать
его в <code><span class="func">funcall</span></code> там, где он вызывается как функция.</p>


<!--\indexR{конфликт имён}-->
<!--\indexR{область видимости!конфликт имён}-->
<p>Наконец, стоит упомянуть радикальное решение, используемое многими языками.
Можно запретить использование одного и того же имени даже в различных
окружениях. Предыдущий пример с <code><span class="func">list</span></code> вызвал бы ошибку, так как
имя <code><span class="var">list</span></code> уже используется в функциональном окружении. Практически все
реализации Лиспа и Scheme запрещают переменной иметь то же имя, что и функция
или макрос. Такое правило действительно облегчает жизнь.</p>


<h2 id="lisp1-2-omega/sect:namespaces"><span class="wrap"><span class="seq">2.5.</span><span class="title">Пространства имён</span></span></h2>

<!--\indexR{пространства имён}-->
<p><em class="term">Окружения</em> устанавливают соответствия между именами и объектами. На данный
момент нам известны два типа окружений: обычное окружение <code><span class="var">env</span></code> и
функциональное <code><span class="var">fenv</span></code>. Причина, по которой они разделены, состоит в желании
ускорить вызовы функций и отделить функции от переменных. Но это разделение
потребовало от нас ввода двух различных вычислителей, а также механизма переноса
сущностей одного окружения в другое, — и это усложнило язык. При обсуждении
динамических переменных мы упомянули, что современные диалекты Лиспа (вроде
ILOG Talk, <span class="sc">E<span class="c">u</span>L<span class="c">isp</span></span>, <span class="sc">ISL<span class="c">isp</span></span>) помещают динамические переменные в отдельное
пространство имён. Сейчас мы подробнее рассмотрим это решение. Занимаясь этим,
мы проиллюстрируем саму идею <em class="term">пространств имён</em>.</p>

<div class="bigskip"></div>

<!--\indexR{привязки (bindings)}-->
<!--\indexR{привязки (bindings)|seealso{связывание}}-->
<!--\indexR{привязки (bindings)!захват}-->
<!--\indexR{объекты!второго класса}-->
<p>Окружения можно понимать как абстрактный тип данных. Они содержат
<em class="term">привязки</em> (bindings) объектов к их именам. Объекты могут быть как
значениями (полноценными объектами первого класса, которые можно передавать,
копировать, присваивать и т. д.), так и сущностями (объектами второго класса,
которыми можно оперировать лишь посредством их имён и, обычно, только
с помощью ограниченного числа специальных форм или иных синтаксических
конструкций). В данный момент нам известен только один тип подобных сущностей
— сами привязки. Они существуют лишь потому, что они — это нечто,
захватываемое замыканиями. Мы рассмотрим их свойства подробнее, когда будем
изучать побочные эффекты.</p>

<p>Есть множество способов использования окружений. Нас может интересовать,
присутствует ли какое-то имя в окружении; мы можем искать объект по его имени;
мы можем искать саму привязку, чтобы изменить её. Мы также можем изменять
окружение, добавляя в него новые привязки, будь это текущее, локальное или
глобальное окружение. Конечно же, не все возможности необходимы для каждого
из окружений. В действительности, многие окружения полезны именно благодаря
накладываемым ими ограничениям. Следующая таблица показывает особенности
окружения переменных Scheme:</p>

<table class="envtable">
<tr><td>Ссылка</td>      <td><i>x</i></td></tr>
<tr><td>Значение</td>    <td><i>x</i></td></tr>
<tr><td>Изменение</td>   <td><code>(<span class="special">set!</span> <i>x</i> ...)</code></td></tr>
<tr><td>Расширение</td>  <td><code>(<span class="special">lambda</span> (... <i>x</i> ...) ...)</code></td></tr>
<tr><td>Определение</td> <td><code>(<span class="special">define</span> <i>x</i> ...)</code></td></tr>
</table>

<p>Мы будем использовать такие таблицы и понятия из них довольно часто при
обсуждении свойств окружений, так что остановимся на них подробнее. Первая
строка показывает синтаксис, используемый для получения ссылки на переменную,
обращения к ней. Вторая строка показывает синтаксис, используемый для получения
значения переменной. В данном случае они совпадают, но так бывает отнюдь
не всегда. Третья строка показывает, как связать переменную с другим значением.
Четвёртая строка показывает, как расширить окружение локальных переменных новой
привязкой: с помощью <code><span class="special">lambda</span></code>-формы или, конечно же, макросов вроде <code><span class="syntax">let</span></code>
или <code><span class="syntax">let*</span></code>, раскрывающихся в <code><span class="special">lambda</span></code>-формы. Наконец, последняя строка
показывает, как определить глобальную переменную. Не волнуйтесь, если эти
различия сейчас для вас кажутся чересчур тонкими и излишними, мы и в дальнейшем
будем использовать подобные таблицы для пояснения вариантов использования
переменных, а там различия будут более заметными.</p>

<p>Например, пространство имён функций Lisp<sub>2</sub>, рассмотренного в начале главы,
описывается следующей таблицей:</p>

<table class="envtable">
<tr><td>Ссылка</td>      <td><code>(<i>f</i> ...)</code></td></tr>
<tr><td>Значение</td>    <td><code>(<span class="special">function</span> <i>f</i>)</code></td></tr>
<tr><td>Изменение</td>   <td>запрещено                            </td></tr>
<tr><td>Расширение</td>  <td><code>(<span class="special">flet</span> (... (<i>f</i> ...) ...) ...)</code></td></tr>
<tr><td>Определение</td> <td>не рассматривалось ранее (<code><span class="special">defun</span></code>)</td></tr>
</table>


<h3 id="lisp1-2-omega/namespaces/ssect:dyn-vars"><span class="wrap"><span class="seq">2.5.1.</span><span class="title">Динамические переменные</span></span></h3>

<!--\indexR{динамические переменные}-->
<!--\indexR{переменные!динамические}-->
<!--\indexR{динамическое окружение}-->
<!--\indexR{окружение!динамическое}-->
<p><em class="term">Динамические переменные</em> принципиально отличаются от лексических, поэтому
имеет смысл отличать их также и на уровне окружений. Следующая таблица
показывает желаемые свойства нашего нового окружения, окружения динамических
переменных:</p>

<table class="envtable">
<tr><td>Ссылка</td>      <td>не может быть получена                       </td></tr>
<tr><td>Значение</td>    <td><code>(<span class="special">dynamic</span> <i>d</i>)</code></td></tr>
<tr><td>Изменение</td>   <td><code>(<span class="special">dynamic-set!</span> <i>d</i> ...)</code></td></tr>
<tr><td>Расширение</td>  <td><code>(<span class="special">dynamic-let</span> (... (<i>d</i> ...) ...) ...)</code></td></tr>
<tr><td>Определение</td> <td>здесь не рассматривается</td></tr>
</table>

<p>Окружение учитывает новые особенности: можно создавать локальные динамические
переменные<a class="footref" href="zz_footnotes.html#foot2.3"><sup>3</sup></a> с помощью формы <code><span class="special">dynamic-let</span></code>, подобной <code><span class="syntax">let</span></code>
и <code><span class="special">flet</span></code>; значение динамической переменной получается с помощью <code><span class="special">dynamic</span></code>,
а изменяется — с помощью <code><span class="special">dynamic-set!</span></code>.</p>

<!--\indexE{Lisp3@\protect\Lisp3}-->
<!--\indexR{Лисп!Lisp3@\protect\Lisp3}-->
<p>Пока что это три специальные формы, но далее будут рассмотрены другие варианты
реализации. А сейчас мы всего лишь добавим в наш интерпретатор <code><span class="func">f.evaluate</span></code>
поддержку динамического окружения: <code><span class="var">denv</span></code>. Это окружение будет содержать
только динамические переменные. Новый интерпретатор, назовём его Lisp<sub>3</sub>, будет
использовать функции с префиксом <code>df.</code>, чтобы не путать их с остальными. Вот
его код. (Форма <code><span class="special">flet</span></code> не показана для краткости.)</p>

<!--\indexC{df.evaluate}-->
<!--\indexC{df.evaluate-application}-->
<!--\indexC{df.make-function}-->
<!--\indexC{df.eprogn}-->
<pre>(<span class="special">define</span> (<span class="func">df.evaluate</span> <span class="var">e</span> <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>)
      (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">lookup</span> <span class="var">e</span> <span class="var">env</span>))
            ((<span class="syntax">or</span> (<span class="func">number?</span> <span class="var">e</span>)(<span class="func">string?</span> <span class="var">e</span>)(<span class="func">char?</span> <span class="var">e</span>)
                 (<span class="func">boolean?</span> <span class="var">e</span>)(<span class="func">vector?</span> <span class="var">e</span>) )
             <span class="var">e</span> )
            (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Cannot evaluate"</span> <span class="var">e</span>)) )
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ((<span class="var">quote</span>)  (<span class="func">cadr</span> <span class="var">e</span>))
        ((<span class="var">if</span>)     (<span class="special">if</span> (<span class="func">df.evaluate</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>)
                      (<span class="func">df.evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>)
                      (<span class="func">df.evaluate</span> (<span class="func">cadddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>) ))
        ((<span class="var">begin</span>)  (<span class="func">df.eprogn</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>))
        ((<span class="var">set!</span>)   (<span class="func">update!</span> (<span class="func">cadr</span> <span class="var">e</span>)
                           <span class="var">env</span>
                           (<span class="func">df.evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>) ))
        ((<span class="var">function</span>)
         (<span class="syntax">cond</span> ((<span class="func">symbol?</span> (<span class="func">cadr</span> <span class="var">e</span>))
                (<span class="func">f.lookup</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">fenv</span>) )
               ((<span class="syntax">and</span> (<span class="func">pair?</span> (<span class="func">cadr</span> <span class="var">e</span>)) (<span class="func">eq?</span> (<span class="func">car</span> (<span class="func">cadr</span> <span class="var">e</span>)) '<span class="var">lambda</span>))
                (<span class="func">df.make-function</span>
                 (<span class="func">cadr</span> (<span class="func">cadr</span> <span class="var">e</span>)) (<span class="func">cddr</span> (<span class="func">cadr</span> <span class="var">e</span>)) <span class="var">env</span> <span class="var">fenv</span> ) )
               (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Incorrect function"</span> (<span class="func">cadr</span> <span class="var">e</span>))) ) )
        ((<span class="var">dynamic</span>) (<span class="func">lookup</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">denv</span>))
        ((<span class="var">dynamic-set!</span>)
         (<span class="func">update!</span> (<span class="func">cadr</span> <span class="var">e</span>)
                  <span class="var">denv</span>
                  (<span class="func">df.evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>) ) )
        ((<span class="var">dynamic-let</span>)
         (<span class="func">df.eprogn</span> (<span class="func">cddr</span> <span class="var">e</span>)
                    <span class="var">env</span>
                    <span class="var">fenv</span>
                    (<span class="func">extend</span> <span class="var">denv</span>
                            (<span class="func">map</span> <span class="var">car</span> (<span class="func">cadr</span> <span class="var">e</span>))
                            (<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">e</span>)
                                   (<span class="func">df.evaluate</span> <span class="var">e</span> <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>) )
                                 (<span class="func">map</span> <span class="var">cadr</span> (<span class="func">cadr</span> <span class="var">e</span>)) ) ) ) )
        (<span class="syntax">else</span> (<span class="func">df.evaluate-application</span> (<span class="func">car</span> <span class="var">e</span>)
                                       (<span class="func">df.evlis</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>)
                                       <span class="var">env</span>
                                       <span class="var">fenv</span>
                                       <span class="var">denv</span> )) ) ) )

(<span class="special">define</span> (<span class="func">df.evaluate-application</span> <span class="var">fn</span> <span class="var">args</span> <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>)
  (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">fn</span>) ((<span class="func">f.lookup</span> <span class="var">fn</span> <span class="var">fenv</span>) <span class="var">args</span> <span class="var">denv</span>))
        ((<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">fn</span>) (<span class="func">eq?</span> (<span class="func">car</span> <span class="var">fn</span>) '<span class="var">lambda</span>))
         (<span class="func">df.eprogn</span> (<span class="func">cddr</span> <span class="var">fn</span>)
                    (<span class="func">extend</span> <span class="var">env</span> (<span class="func">cadr</span> <span class="var">fn</span>) <span class="var">args</span>)
                    <span class="var">fenv</span>
                    <span class="var">denv</span> ) )
        (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Incorrect functional term"</span> <span class="var">fn</span>)) ) )

(<span class="special">define</span> (<span class="func">df.make-function</span> <span class="var">variables</span> <span class="var">body</span> <span class="var">env</span> <span class="var">fenv</span>)
  (<span class="special">lambda</span> (<span class="var">values</span> <span class="var">denv</span>)
    (<span class="func">df.eprogn</span> <span class="var">body</span> (<span class="func">extend</span> <span class="var">env</span> <span class="var">variables</span> <span class="var">values</span>) <span class="var">fenv</span> <span class="var">denv</span>) ) )

(<span class="special">define</span> (<span class="func">df.eprogn</span> <span class="var">e*</span> <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e*</span>)
      (<span class="special">if</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">e*</span>))
          (<span class="special">begin</span> (<span class="func">df.evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>)
                 (<span class="func">df.eprogn</span> (<span class="func">cdr</span> <span class="var">e*</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>) )
          (<span class="func">df.evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>) )
      <span class="var">empty-begin</span> ) )</pre>

<p>Для поддержки нового окружения, <code><span class="var">denv</span></code>, потребовалось изменить прототипы
<code><span class="func">df.evaluate</span></code> и <code><span class="func">df.eprogn</span></code>, чтобы не терять это окружение при
вычислениях. Далее, <code><span class="func">df.evaluate</span></code> определяет три новые специальные формы
для операций над <code><span class="var">denv</span></code>, динамическим окружением. Есть и менее заметные
изменения: <code><span class="func">df.evaluate-application</span></code> передаёт в функции
<em>текущее</em>
динамическое окружение. Мы уже встречались с таким поведением
<span class="see">[см. раздел <a href="ch01_basics.html#basics/representing-functions/fixing/src:inject-current-env">1.6</a>]</span>, когда
были вынуждены передавать текущее лексическое окружение в вызываемую функцию.</p>

<!--\indexR{динамическое окружение!варианты}-->
<!--\indexR{окружение!динамическое!варианты}-->
<p>При применении функции используются одновременно несколько окружений. Есть
окружение с переменными и функциями, захваченными при определении функции. Есть
также окружение с динамическими переменными, существующими в момент вызова. Это
окружение не может быть захвачено и сохранено в замыкании, каждый раз значение
динамической переменной ищется заново в текущем динамическом окружении. Оно
может там отсутствовать, что, конечно же, приводит к ошибке. Возможны и другие
варианты реализации: например, сделать единое глобальное окружение динамических
переменных, как в <span class="sc">ISL<span class="c">isp</span></span>; или выдать каждому модулю собственное динамическое
окружение, как в <span class="sc">E<span class="c">u</span>L<span class="c">isp</span></span>; или даже иметь глобальное окружение лексических
переменных, как в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>.
<span class="see">[см. раздел <a href="#lisp1-2-omega/namespaces/ssect:dyn-vars-cl">2.5.2</a>]</span></p>

<p>Одно из преимуществ отдельного окружения: становится чётко видно, какие
переменные динамические, а какие нет. При всяком обращении к динамическому
окружению необходимо использовать специальную форму с префиксом <code><span class="special">dynamic</span></code>.
Явные обращения к динамическим переменным невозможно не заметить. Это очень
важно, так как в Lisp<sub>3</sub> поведение функции определяется не только значениями
локальных переменных, но и текущим состоянием динамического окружения. </p>

<!--\indexR{привязки (bindings)!динамические}-->
<!--\indexR{обработка ошибок!динамические переменные}-->
<p>Среди традиционных вариантов использования динамических окружений наиболее
полезным является обработка ошибок. При возникновении ошибки или исключительной
ситуации создаётся некий объект, описывающий, что произошло, и к этому объекту
применяется соответствующая функция, которая обработает исключительную ситуацию
(и, возможно, попытается восстановить работоспособность программы). Этот
обработчик мог бы быть общей глобальной функцией, но это потребовало бы кучи
ненужных присваиваний для использования правильного обработчика в правильное
время. «Герметичность» лексических окружений плохо сочетается со сквозным
указанием различных функций-обработчиков. Хотя мы всегда можем ограничить время
жизни локальных переменных, заключив вычисления в <code><span class="syntax">let</span></code> или <code><span class="special">dynamic-let</span></code>,
но у <code><span class="special">dynamic-let</span></code> есть несколько серьёзных преимуществ:</p>

<ul>
  <li>создаваемые привязки не могут быть захвачены;</li>

  <li>эти привязки доступны только во время вычислений, вложенных в форму;</li>

  <li>привязки автоматически уничтожаются после завершения вычислений.</li>
</ul>

<p class="noindent">Поэтому <code><span class="special">dynamic-let</span></code>
идеально подходит для временной установки функций-обработчиков ошибок.</p>

<p>Вот ещё один пример разумного использования динамических переменных. Функции
вывода в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> настраиваются динамическими переменными вроде
<code><span class="var">*print-base*</span></code>, <code><span class="var">*print-circle*</span></code> и т. д. В них хранится информация
об основании счисления для вывода чисел, о том, могут ли выводимые данные
содержать циклические списки, и тому подобное. Конечно, можно передавать всю
эту информацию через аргументы, но только представьте, что вместо
<code>(<span class="func">print</span> <i>выражение</i>)</code>
приходилось бы писать <code>(<span class="func">print</span> <i>выражение</i>
<i>escape-символы?</i> <i>основание</i> <i>циклы?</i> <i>pretty-print?</i> <i>регистр?</i>
<i>уровень-вложенности</i> <i>векторы?</i> <i>использовать-gensym?</i>)</code>. Каждый раз.
Динамические переменные позволяют один раз установить значения по умолчанию для таких параметров
и больше никогда их не указывать, если не требуется особого поведения.</p>

<!--\indexR{циклические структуры данных}-->
<p>Scheme использует похожий механизм для указания портов ввода-вывода. Можно
написать <code>(<span class="func">display</span> <i>выражение</i>)</code> или<a class="footref"
href="zz_footnotes.html#foot2.4"><sup>4</sup></a> <code>(<span class="func">display</span>
<i>выражение</i> <i>порт</i>)</code>.
Первая форма, с одним аргументом, выводит <i>выражение</i> в текущий порт вывода.
Вторая же использует явно указанный порт. Функция <code><span class="func">with-output-to-file</span></code>
позволяет указать порт вывода, который будет текущим на время вычисления
выражения. Узнать текущий порт можно с помощью <code><span class="func">current-output-port</span></code>. Вот так
определяется функция,<a class="footref" href="zz_footnotes.html#foot2.5"><sup>5</sup></a> которая
выводит циклические списки в текущий порт:</p>

<!--\indexC{display-cyclic-spine}-->
<pre>(<span class="special">define</span> (<span class="func">display-cyclic-spine</span> <span class="var">list</span>)
  (<span class="special">define</span> (<span class="func">scan</span> <span class="var">l1</span> <span class="var">l2</span> <span class="var">flip</span>)
    (<span class="syntax">cond</span> ((<span class="func">atom?</span> <span class="var">l1</span>)  (<span class="syntax">unless</span> (<span class="func">null?</span> <span class="var">l1</span>)
                          (<span class="func">display</span> <span class="string">" . "</span>) (<span class="func">display</span> <span class="var">l1</span>) )
                       (<span class="func">display</span> <span class="string">")"</span>) )
          ((<span class="func">eq?</span> <span class="var">l1</span> <span class="var">l2</span>) (<span class="func">display</span> <span class="string">"...)"</span>))
          (<span class="syntax">else</span>        (<span class="func">display</span> (<span class="func">car</span> <span class="var">l1</span>))
                       (<span class="syntax">when</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">l1</span>)) (<span class="func">display</span> <span class="string">" "</span>))
                       (<span class="func">scan</span> (<span class="func">cdr</span> <span class="var">l1</span>)
                             (<span class="special">if</span> (<span class="syntax">and</span> <span class="var">flip</span> (<span class="func">pair?</span> <span class="var">l2</span>))
                                 (<span class="func">cdr</span> <span class="var">l2</span>)
                                 <span class="var">l2</span> )
                             (<span class="func">not</span> <span class="var">flip</span>) ) ) ) )
  (<span class="func">display</span> <span class="string">"("</span>)
  (<span class="func">scan</span> <span class="var">list</span> (<span class="func">cons</span> <span class="num">42</span> <span class="var">list</span>) <span class="hash">#f</span>) )

(<span class="func">display-cyclic-spine</span>        <span class="comment">; напечатает <code>(<span class="num">1</span> <span class="num">2</span> <span class="num">3</span> <span class="num">4</span> <span class="num">1</span> ...)</code></span>
  (<span class="syntax">let</span> ((<span class="var">l</span> (<span class="func">list</span> <span class="num">1</span> <span class="num">2</span> <span class="num">3</span> <span class="num">4</span>)))
    (<span class="func">set-cdr!</span> (<span class="func">cdddr</span> <span class="var">l</span>) <span class="var">l</span>)
    <span class="var">l</span> ) )</pre>

<p>Можно даже составить таблицу характеристик для портов вывода Scheme:</p>

<table class="envtable">
<tr><td>Ссылка</td>      <td>автоматически, если не упоминается явно</td></tr>
<tr><td>Значение</td>    <td><code>(<span class="func">current-output-port</span>)</code></td></tr>
<tr><td>Изменение</td>   <td>запрещено</td></tr>
<tr><td>Расширение</td>  <td><code>(<span class="func">with-output-to-file</span> <i>имя-файла</i> <i>замыкание</i>)</code></td></tr>
<tr><td>Определение</td> <td>неприменимо</td></tr>
</table>

<!--\indexC*{standard-output}{*standard-output*}-->
<!--\indexR{соглашения именования!динамических переменных}-->
<p>В <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> данный механизм явно использует динамические переменные.
По умолчанию функции вывода вроде <code><span class="func">print</span></code> или <code><span class="func">write</span></code> используют порт,
хранящийся в переменной <code><span class="var">*standard-output*</span></code>.<a class="footref"
href="zz_footnotes.html#foot2.6"><sup>6</sup></a> Мы можем
проэмулировать<a class="footref" href="zz_footnotes.html#foot2.7"><sup>7</sup></a> <code><span class="func">with-output-to-file</span></code> следующим образом:</p>

<!--\indexC{with-output-to-file}-->
<pre>(<span class="special">define</span> (<span class="func">with-output-to-file</span> <span class="var">filename</span> <span class="var">thunk</span>)
  (<span class="special">dynamic-let</span> ((<span class="var">*standard-output*</span> (<span class="func">open-input-file</span> <span class="var">filename</span>)))
    (<span class="func">thunk</span>) ) )</pre>


<h3 id="lisp1-2-omega/namespaces/ssect:dyn-vars-cl"><span class="wrap"><span class="seq">2.5.2.</span><span class="title">Динамические переменные в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span></span></span></h3>

<!--\indexR{динамические переменные!синтаксис}-->
<!--\indexR{синтаксис!динамических переменных}-->
<p>Хотя <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> разделяет динамические и лексические переменные с точки
зрения вычислений, но синтаксис их использования отличается слабо. В нём нет
формы <code><span class="special">dynamic-let</span></code>, но её можно легко сымитировать:</p>

<table class="nocaption code"><tbody><tr>
<td><pre>(<span class="special">dynamic-let</span> ((<span class="var">x</span> <span class="math"><span class="ord var">α</span></span>))
  <span class="math"><span class="ord var">β</span></span> )</pre></td>
<td><span class="math"><span class="ord"></span><span class="rel">≡</span><span class="ord"></span></span></td>
<td><pre>(<span class="syntax">let</span> ((<span class="var">x</span> <span class="math"><span class="ord var">α</span></span>))
  (<span class="special">declare</span> (<span class="syntax">special</span> <span class="var">x</span>))
  <span class="math"><span class="ord var">β</span></span> )</pre></td>
</tr></tbody></table>

<p>Отличие состоит в том, что для получения значения динамической переменной <code><span class="var">x</span></code>
внутри <span class="math"><span class="ord var">β</span></span> нет надобности использовать форму <code><span class="special">dynamic</span></code>, достаточно писать
просто <code><span class="var">x</span></code>. Причина такого поведения в том, что выражение
<code>(<span class="special">declare</span> (<span class="syntax">special</span> <span class="var">x</span>))</code> означает сразу две вещи: привязка, устанавливаемая <code><span class="syntax">let</span></code>
для <code><span class="var">x</span></code> должна быть динамической, а каждая ссылка на <code><span class="var">x</span></code> внутри
тела <code><span class="syntax">let</span></code> должно пониматься как <code>(<span class="special">dynamic</span> <span class="var">x</span>)</code>.</p>

<p>Это не совсем удобно, так как внутри <span class="math"><span class="ord var">β</span></span> нельзя обращаться к лексической
переменной <code><span class="var">x</span></code>, нам будет видна только её динамическая тёзка. Можно было бы
пойти другим путём, указывая конкретные места, где необходимо использовать
динамическую переменную <code><span class="var">x</span></code> с помощью конструкции
<code>(<span class="special">locally</span> (<span class="special">declare</span> (<span class="syntax">special</span> <span class="var">x</span>)) <span class="var">x</span>)</code>. Это в точности идентично нашей форме <code><span class="special">dynamic</span></code>.</p>

<p>Стратегия <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> состоит в указании типа привязки с помощью конструкций
языка. Мы можем реализовать этот механизм, сделав следующие изменения
в интерпретаторе:</p>

<!--\indexC{df.evaluate}-->
<!--\indexC{special-extend}-->
<!--\indexC{cl.lookup}-->
<pre>(<span class="special">define</span> (<span class="func">df.evaluate</span> <span class="var">e</span> <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>)
      (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">cl.lookup</span> <span class="var">e</span> <span class="var">env</span>))
            ((<span class="syntax">or</span> (<span class="func">number?</span> <span class="var">e</span>)(<span class="func">string?</span> <span class="var">e</span>)(<span class="func">char?</span> <span class="var">e</span>)
                 (<span class="func">boolean?</span> <span class="var">e</span>)(<span class="func">vector?</span> <span class="var">e</span>) )
             <span class="var">e</span> )
            (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Cannot evaluate"</span> <span class="var">e</span>)) )
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ((<span class="var">quote</span>)  (<span class="func">cadr</span> <span class="var">e</span>))
        ((<span class="var">if</span>)     (<span class="special">if</span> (<span class="func">df.evaluate</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>)
                      (<span class="func">df.evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>)
                      (<span class="func">df.evaluate</span> (<span class="func">cadddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>) ))
        ((<span class="var">begin</span>)  (<span class="func">df.eprogn</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>))
        ((<span class="var">set!</span>)   (<span class="func">update!</span> (<span class="func">cadr</span> <span class="var">e</span>)
                           <span class="var">env</span>
                           (<span class="func">df.evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>) ))
        ((<span class="var">function</span>)
         (<span class="syntax">cond</span> ((<span class="func">symbol?</span> (<span class="func">cadr</span> <span class="var">e</span>))
                (<span class="func">f.lookup</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">fenv</span>) )
               ((<span class="syntax">and</span> (<span class="func">pair?</span> (<span class="func">cadr</span> <span class="var">e</span>)) (<span class="func">eq?</span> (<span class="func">car</span> (<span class="func">cadr</span> <span class="var">e</span>)) '<span class="var">lambda</span>))
                (<span class="func">df.make-function</span>
                 (<span class="func">cadr</span> (<span class="func">cadr</span> <span class="var">e</span>)) (<span class="func">cddr</span> (<span class="func">cadr</span> <span class="var">e</span>)) <span class="var">env</span> <span class="var">fenv</span> ) )
               (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Incorrect function"</span> (<span class="func">cadr</span> <span class="var">e</span>))) ) )
        ((<span class="var">dynamic</span>) (<span class="func">lookup</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">denv</span>))
        ((<span class="var">dynamic-set!</span>)
         (<span class="func">update!</span> (<span class="func">cadr</span> <span class="var">e</span>)
                  <span class="var">denv</span>
                  (<span class="func">df.evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>) ) )
        ((<span class="var">dynamic-let</span>)
         (<span class="func">df.eprogn</span> (<span class="func">cddr</span> <span class="var">e</span>)
                    <span class="highlight">(<span class="func">special-extend</span> <span class="var">env</span></span>
                                    <span class="highlight">(<span class="func">map</span> <span class="var">car</span> (<span class="func">cadr</span> <span class="var">e</span>)) )</span>
                    <span class="var">fenv</span>
                    (<span class="func">extend</span> <span class="var">denv</span>
                            (<span class="func">map</span> <span class="var">car</span> (<span class="func">cadr</span> <span class="var">e</span>))
                            (<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">e</span>)
                                   (<span class="func">df.evaluate</span> <span class="var">e</span> <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>) )
                                 (<span class="func">map</span> <span class="var">cadr</span> (<span class="func">cadr</span> <span class="var">e</span>)) ) ) ) )
        (<span class="syntax">else</span> (<span class="func">df.evaluate-application</span> (<span class="func">car</span> <span class="var">e</span>)
                                       (<span class="func">df.evlis</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">fenv</span> <span class="var">denv</span>)
                                       <span class="var">env</span>
                                       <span class="var">fenv</span>
                                       <span class="var">denv</span> )) ) ) )

(<span class="special">define</span> (<span class="func">special-extend</span> <span class="var">env</span> <span class="var">variables</span>)
  (<span class="func">append</span> <span class="var">variables</span> <span class="var">env</span>) )

(<span class="special">define</span> (<span class="func">cl.lookup</span> <span class="var">var</span> <span class="var">env</span> <span class="var">denv</span>)
  (<span class="syntax">let</span> <span class="func">look</span> ((<span class="var">env</span> <span class="var">env</span>))
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">env</span>)
        (<span class="special">if</span> (<span class="func">pair?</span> (<span class="func">car</span> <span class="var">env</span>))
            (<span class="special">if</span> (<span class="func">eq?</span> (<span class="func">caar</span> <span class="var">env</span>) <span class="var">var</span>)
                (<span class="func">cdar</span> <span class="var">env</span>)
                (<span class="func">look</span> (<span class="func">cdr</span> <span class="var">env</span>)) )
            (<span class="special">if</span> (<span class="func">eq?</span> (<span class="func">car</span> <span class="var">env</span>) <span class="var">var</span>)
                <span class="comment">;; ищем в текущем динамическом окружении</span>
                (<span class="syntax">let</span> <span class="func">lookup-in-denv</span> ((<span class="var">denv</span> <span class="var">denv</span>))
                  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">denv</span>)
                      (<span class="special">if</span> (<span class="func">eq?</span> (<span class="func">caar</span> <span class="var">denv</span>) <span class="var">var</span>)
                          (<span class="func">cdar</span> <span class="var">denv</span>)
                          (<span class="func">lookup-in-denv</span> (<span class="func">cdr</span> <span class="var">denv</span>)) )
                      <span class="comment">;; если не находим, ищем в глобальном лексическом</span>
                      (<span class="func">lookup</span> <span class="var">var</span> <span class="var">env.global</span>) ) )
                (<span class="func">look</span> (<span class="func">cdr</span> <span class="var">env</span>)) ) )
        (<span class="func">wrong</span> <span class="string">"No such binding"</span> <span class="var">var</span>) ) ) )</pre>

<p>Теперь разберём, как это работает. Когда <code><span class="special">dynamic-let</span></code> создаёт динамическую
переменная, она не только связывает её со значением в динамическом окружении, но
и помечает её как динамическую в лексическом окружении, записывая туда её имя.
Для поддержки этих меток изменяется механизм поиска значения по ссылке
(<code><span class="func">cl.lookup</span></code>): он должен проанализировать ссылку, чтобы определить тип
привязки (лексическая или динамическая), после чего отыскать значение
в правильном окружении. Также, если переменная не найдена в текущем динамическом
окружении, то следующим просматривается глобальное лексическое окружение,
которое в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> одновременно является глобальным динамическим.</p>

<p>Приведём пример работы такого Lisp<sub>3</sub>, имитирующего <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>:</p>

<pre>(<span class="special">dynamic-let</span> ((<span class="var">x</span> <span class="num">2</span>))
  <span class="func">(+</span> <span class="var">x</span>                        <span class="comment">; динамический <code><span class="var">x</span></code></span>
     (<span class="syntax">let</span> ((<span class="var">x</span> (<span class="func">+</span>              <span class="comment">; лексический</span>
                 <span class="var">x</span> <span class="var">x</span> )))      <span class="comment">; динамические</span>
       <span class="func">(+</span> <span class="var">x</span>                   <span class="comment">; лексический</span>
          (<span class="special">dynamic</span> <span class="var">x</span>) ) ) ) ) <span class="comment">; динамический</span>
<span class="math"><span class="rel">→</span></span> <span class="num">8</span></pre>


<h3 id="lisp1-2-omega/namespaces/ssect:dyn-vars-no-special"><span class="wrap"><span class="seq">2.5.3.</span><span class="title">Динамические переменные без специальных форм</span></span></h3>

<p>Сейчас для работы с динамическими переменными используются целых три специальные
формы. Так как Scheme исповедует минимализм по отношению к количеству
специальных форм, стоит подумать о других вариантах. Не будем рассматривать их
все, а остановимся на следующем, так как он использует всего две функции. Первая
функция динамически связывает два значения; вторая функция может по первому
значению найти второе. На роль идентификаторов динамических переменных прекрасно
подходят символы. Кроме них нам потребуется некий изменяемый тип данных вроде
точечных пар, если мы хотим изменять установленные связи. Так наше решение будет
удовлетворять аскетичным традициям Scheme.</p>

<p>Во время изучения данного подхода мы будем использовать интерпретатор с двумя
окружениями: <code><span class="var">env</span></code> и
<code><span class="var">denv</span></code>. Это тот же предыдущий интерпретатор, только
из него убрано несколько вещей: ненужные специальные формы, поддержка
функциональных окружений и ссылки на переменные как в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>.
Остались только мы и динамические окружения. Такой интерпретатор несколько менее полезен,
так как динамическое окружение уже нельзя расширять непосредственно, но, тем
не менее, это окружение всё ещё передаётся в каждую функцию — и этого
достаточно! Чтобы отличать эту вариацию от предыдущих, её функциям выдан
префикс <code>dd</code>.</p>

<!--\indexC{dd.evaluate}-->
<!--\indexC{dd.make-function}-->
<!--\indexC{dd.evlis}-->
<!--\indexC{dd.eprogn}-->
<pre>(<span class="special">define</span> (<span class="func">dd.evaluate</span> <span class="var">e</span> <span class="var">env</span> <span class="var">denv</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>)
      (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">lookup</span> <span class="var">e</span> <span class="var">env</span>))
            ((<span class="syntax">or</span> (<span class="func">number?</span> <span class="var">e</span>)(<span class="func">string?</span> <span class="var">e</span>)(<span class="func">char?</span> <span class="var">e</span>)
                 (<span class="func">boolean?</span> <span class="var">e</span>)(<span class="func">vector?</span> <span class="var">e</span>) )
             <span class="var">e</span> )
            (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Cannot evaluate"</span> <span class="var">e</span>)) )
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ((<span class="var">quote</span>)  (<span class="func">cadr</span> <span class="var">e</span>))
        ((<span class="var">if</span>)     (<span class="special">if</span> (<span class="func">dd.evaluate</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">denv</span>)
                      (<span class="func">dd.evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">denv</span>)
                      (<span class="func">dd.evaluate</span> (<span class="func">cadddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">denv</span>) ))
        ((<span class="var">begin</span>)  (<span class="func">dd.eprogn</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">denv</span>))
        ((<span class="var">set!</span>)   (<span class="func">update!</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span>
                           (<span class="func">dd.evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">denv</span>) ))
        ((<span class="var">lambda</span>) (<span class="func">dd.make-function</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">env</span>))
        (<span class="syntax">else</span> (<span class="func">invoke</span> (<span class="func">dd.evaluate</span> (<span class="func">car</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">denv</span>)
                      (<span class="func">dd.evlis</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span> <span class="var">denv</span>)
                      <span class="var">denv</span> )) ) ) )

(<span class="special">define</span> (<span class="func">dd.make-function</span> <span class="var">variables</span> <span class="var">body</span> <span class="var">env</span>)
  (<span class="special">lambda</span> (<span class="var">values</span> <span class="var">denv</span>)
    (<span class="func">dd.eprogn</span> <span class="var">body</span> (<span class="func">extend</span> <span class="var">env</span> <span class="var">variables</span> <span class="var">values</span>) <span class="var">denv</span>) ) )

(<span class="special">define</span> (<span class="func">dd.evlis</span> <span class="var">e*</span> <span class="var">env</span> <span class="var">denv</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e*</span>)
      (<span class="special">if</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">e*</span>))
          (<span class="func">cons</span> (<span class="func">dd.evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">env</span> <span class="var">denv</span>)
                (<span class="func">dd.evlis</span> (<span class="func">cdr</span> <span class="var">e*</span>) <span class="var">env</span> <span class="var">denv</span>) )
          (<span class="func">list</span> (<span class="func">dd.evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">env</span> <span class="var">denv</span>)) )
      <span class="hash">'()</span> ) )

(<span class="special">define</span> (<span class="func">dd.eprogn</span> <span class="var">e*</span> <span class="var">env</span> <span class="var">denv</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e*</span>)
      (<span class="special">if</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">e*</span>))
          (<span class="special">begin</span> (<span class="func">dd.evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">env</span> <span class="var">denv</span>)
                 (<span class="func">dd.eprogn</span> (<span class="func">cdr</span> <span class="var">e*</span>) <span class="var">env</span> <span class="var">denv</span>) )
          (<span class="func">dd.evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">env</span> <span class="var">denv</span>) )
      <span class="var">empty-begin</span> ) )</pre>

<p>Как мы и обещали, теперь определим две функции. Первую назовём
<code><span class="func">bind-with-dynamic-extent</span></code>; это длинное название, так что сократим его до
<code><span class="func">bind/de</span></code>. Первым её аргументом является ключ <code><span class="var">tag</span></code>; вторым —
значение <code><span class="var">value</span></code>, связываемое с ключом; третьим — замыкание <code><span class="var">thunk</span></code>,
функция без аргументов, которая будет вызвана в расширенном динамическом
окружении.</p>

<!--\indexC{bind/de}-->
<pre>(<span class="syntax">definitial</span> <span class="var">bind/de</span>
  (<span class="special">lambda</span> (<span class="var">values</span> <span class="var">denv</span>)
    (<span class="special">if</span> (<span class="func">=</span> <span class="num">3</span> (<span class="func">length</span> <span class="var">values</span>))
        (<span class="syntax">let</span> ((<span class="var">tag</span>   (<span class="func">car</span> <span class="var">values</span>))
              (<span class="var">value</span> (<span class="func">cadr</span> <span class="var">values</span>))
              (<span class="var">thunk</span> (<span class="func">caddr</span> <span class="var">values</span>)) )
          (<span class="func">invoke</span> <span class="var">thunk</span> <span class="hash">'()</span>
                  (<span class="func">extend</span> <span class="var">denv</span> (<span class="func">list</span> <span class="var">tag</span>) (<span class="func">list</span> <span class="var">value</span>)) ) )
        (<span class="func">wrong</span> <span class="string">"Incorrect arity"</span> '<span class="var">bind/de</span>) ) ) )</pre>

<p>Следующая функция будет использовать динамическое окружение. Так как нам надо
что-то делать в случае, если динамической переменной с запрошенным именем нет,
то функция <code><span class="func">assoc/de</span></code> первым аргументом принимает ключ, а вторым —
функцию. Она вызовет полученную функцию и передаст ей ключ, если не найдёт его
в динамическом окружении.</p>

<!--\indexC{assoc/de}-->
<pre>(<span class="syntax">definitial</span> <span class="var">assoc/de</span>
  (<span class="special">lambda</span> (<span class="var">values</span> <span class="var">current.denv</span>)
    (<span class="special">if</span> (<span class="func">=</span> <span class="num">2</span> (<span class="func">length</span> <span class="var">values</span>))
        (<span class="syntax">let</span> ((<span class="var">tag</span>     (<span class="func">car</span> <span class="var">values</span>))
              (<span class="var">default</span> (<span class="func">cadr</span> <span class="var">values</span>)) )
          (<span class="syntax">let</span> <span class="func">look</span> ((<span class="var">denv</span> <span class="var">current.denv</span>))
            (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">denv</span>)
                (<span class="special">if</span> (<span class="func">eqv?</span> <span class="var">tag</span> (<span class="func">caar</span> <span class="var">denv</span>))
                    (<span class="func">cdar</span> <span class="var">denv</span>)
                    (<span class="func">look</span> (<span class="func">cdr</span> <span class="var">denv</span>)) )
                (<span class="func">invoke</span> <span class="var">default</span> (<span class="func">list</span> <span class="var">tag</span>) <span class="var">current.denv</span>) ) ) )
        (<span class="func">wrong</span> <span class="string">"Incorrect arity"</span> '<span class="var">assoc/de</span>) ) ) )</pre>

<p>Можно реализовать несколько вариантов её поведения в зависимости от используемого механизма
сравнения (<code><span class="func">eqv?</span></code> или
<code><span class="func">equal?</span></code>).
<span class="see">[см. упр. <a href="#lisp1-2-omega/ex:assoc-with-comparator">2.4</a>]</span></p>

<p>Перепишем предыдущий пример:</p>

<pre>(<span class="func">bind/de</span> '<span class="var">x</span> <span class="num">2</span>
  (<span class="special">lambda</span> () (<span class="func">+</span> (<span class="func">assoc/de</span> '<span class="var">x</span> <span class="var">error</span>)
                (<span class="syntax">let</span> ((<span class="var">x</span> (<span class="func">+</span> (<span class="func">assoc/de</span> '<span class="var">x</span> <span class="var">error</span>)
                            (<span class="func">assoc/de</span> '<span class="var">x</span> <span class="var">error</span>) )))
                  (<span class="func">+</span> <span class="var">x</span> (<span class="func">assoc/de</span> '<span class="var">x</span> <span class="var">error</span>)) ) )) )
<span class="math"><span class="rel">→</span></span> <span class="num">8</span></pre>

<p>Таким образом, мы опровергли необходимость использования специальных форм для
реализации механизма динамических переменных. Заодно мы получили возможность
связывать что угодно с чем угодно. Конечно, это преимущество — ничто по
сравнению с тем, что есть гораздо более эффективные реализации динамических
переменных (даже без учёта многопоточности). Хотя бы то же ближнее связывание,
которое лишь требует, чтобы ключ был символом.<a class="footref" href="zz_footnotes.html#foot2.8"><sup>8</sup></a> С другой стороны, в данном варианте не потеряна
ссылочная прозрачность. Но всё равно доступ к динамическим переменным требует
недешёвых вызовов функций. Наше решение ещё довольно далеко от органичного
сочетания динамических и лексических переменных в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>.</p>

<p>Среди всех неудобств стоит отметить ещё то, что использование <code><span class="func">bind/de</span></code>
требует использования <code><span class="func">assoc/de</span></code> и написания функции-обработчика. Хотя,
естественно, с помощью макросов это можно спрятать. Другое неудобство возникает
уже для компилятора: ведь ему надо будет генерировать код для создания и
использования динамических переменных. К счастью, они помечены вызовами
соответствующих функций, так что дальнейшее отдаётся на откуп компилятору:
генерировать код в лоб (это легче) или вставить свою, более эффективную
реализацию.</p>


<h3 id="lisp1-2-omega/namespaces/ssect:conclusions"><span class="wrap"><span class="seq">2.5.4.</span><span class="title">В заключение о пространствах имён</span></span></h3>

<p>После отступления к динамическим переменным, вернёмся к идее пространств имён
в общем: специализированные окружения для специализированных объектов. Мы уже
видели Lisp<sub>3</sub> в деле, а также разобрали механизм динамических переменных
в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>.</p>

<!--\indexE{Lispn@\protect\Lisp{\protect\ii{n}}}-->
<!--\indexR{Лисп!Lispn@\protect\Lisp{\protect\ii{n}}}-->
<p>Тем не менее, наша последняя реализация — та, что с двумя функциями вместо
трёх специальных форм, — поднимает каверзный вопрос. Если это Lisp<sub><i>n</i></sub>, то
чему равно <i>n</i>? Базируется она на Scheme, но всё же явно имеет два окружения:
<code><span class="var">env</span></code> и <code><span class="var">denv</span></code>. В то же время, вычислитель у неё лишь один, что является
отличительной чертой Scheme и класса Lisp<sub>1</sub>. Однако, нам пришлось довольно
сильно модифицировать интерпретатор (просто сравните <code><span class="func">evaluate</span></code> и
<code><span class="func">dd.evaluate</span></code>), чтобы реализовать функции <code><span class="func">bind/de</span></code> и <code><span class="func">assoc/de</span></code>. Мы
столкнулись с примитивными функциями, которые нельзя выразить тем же языком,
если только они уже не определены; более того, само существование этих функций
глубоко влияет на процесс вычислений. В следующей главе будет такая же ситуация
с <code><span class="func">call/cc</span></code>.</p>

<!--\indexR{списки свойств}-->
<!--\indexR{символы!списки свойств}-->
<p>Короче говоря, похоже, что у нас получился Lisp<sub>1</sub>, если смотреть на количество
вычислителей, и Lisp<sub>2</sub> — если смотреть на пространства имён. Обобщением этих
парадоксов является мнение, что наличие списка свойств у символов является
чертой Lisp<sub><i>n</i></sub>, где <i>n</i> может быть произвольным.
<span class="see">[см. упр. <a href="#lisp1-2-omega/ex:write-put/get-prop">2.6</a>]</span>
Так как наши пространства имён объективно существуют, а значения соответствующих
переменных вычисляются особым образом (пусть и с помощью примитивных функций, а
не специальных форм), то будем считать нашу реализацию представителем
класса Lisp<sub>2</sub>.</p>

<div class="bigskip"></div>

<!--\indexC{csetq}-->
<!--\indexR{константы}-->
<p>Остаётся ещё один урок, который можно извлечь из рассмотрения лексических и
динамических переменных. <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> старается унифицировать доступ
к переменным из различных пространств имён, предоставляя одинаковый синтаксис.
Поэтому необходимо знать правила, по которым он определяет, из какого
пространства имён взять переменную. К сожалению, они не всегда однозначны;
например, <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> не различает глобальное динамическое и глобальное
лексическое окружения. Далее, в <span class="sc">L<span class="c">isp</span> 1.5</span> существовала концепция констант,
определяемых специальной формой <code><span class="special">csetq</span></code> (<code><span class="special">setq</span></code> для констант).</p>

<table class="envtable">
<tr><td>Ссылка</td>      <td><i>x</i></td></tr>
<tr><td>Значение</td>    <td><i>x</i></td></tr>
<tr><td>Изменение</td>   <td><code>(<span class="special">csetq</span> <i>x</i> <i>форма</i>)</code></td></tr>
<tr><td>Расширение</td>  <td>запрещено</td></tr>
<tr><td>Определение</td> <td><code>(<span class="special">csetq</span> <i>x</i> <i>форма</i>)</code></td></tr>
</table>

<p>Введение констант тоже делает синтаксис неоднозначным. Когда мы пишем <code><span class="var">foo</span></code>
— это может быть как константа, так и переменная. Правило разрешения
противоречий в <span class="sc">L<span class="c">isp</span> 1.5</span> было таково: если существует константа с именем
<code><span class="var">foo</span></code>, то вернуть её значение; иначе искать одноимённую переменную
в лексическом пространстве имён. Но: «константы» можно изменять (представьте
себе!) с помощью той же формы <code><span class="special">csetq</span></code>, что используется для их создания.
Таким образом, константы <span class="sc">L<span class="c">isp</span> 1.5</span> соответствуют глобальным переменным Scheme,
только с обратным приоритетом: в Scheme сначала ищется локальная лексическая
переменная, а глобальная переменная является лишь значением по умолчанию на
случай, если локальная переменная не будет найдена.</p>

<p>Проблема имеет довольно общий характер. Если для доступа к нескольким
пространствам имён используется одинаковый синтаксис, то необходимы чётко
прописанные правила разрешения неоднозначностей.</p>


<h2 id="lisp1-2-omega/sect:recursion"><span class="wrap"><span class="seq">2.6.</span><span class="title">Рекурсия</span></span></h2>

<!--\indexR{рекурсия}-->
<!--\indexR{рекурсия|seealso{рекурсия}}-->
<!--\indexR{рекурсия|\protect-->
<!--\indexR{рекурсия}}-->
<p>Рекурсия естественна для Лиспа, но мы пока так ничего и не сказали о том, как же
она реализуется. Далее мы проанализируем различные типы рекурсии и вызываемые
ими проблемы.</p>


<h3 id="lisp1-2-omega/recusion/ssect:simple"><span class="wrap"><span class="seq">2.6.1.</span><span class="title">Простая рекурсия</span></span></h3>

<!--\indexR{рекурсия!простая}-->
<p>Наверное, наиболее известной простой рекурсивной функцией является факториал,
определяемый следующим образом:</p>

<!--\indexC{fact}-->
<pre>(<span class="special">define</span> (<span class="func">fact</span> <span class="var">n</span>)
  (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
      (<span class="func">*</span> <span class="var">n</span> (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) )</pre>

<p>Язык, который был определён в предыдущей главе, не знает, что такое <code><span class="special">define</span></code>,
так что давайте представим, что это макрос, который раскрывается в следующий
код:</p>

<pre>(<span class="special">set!</span> <span class="var">fact</span> (<span class="special">lambda</span> (<span class="var">n</span>)
             (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
                 (<span class="func">*</span> <span class="var">n</span> (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) ))</pre>

<!--\indexR{привязки (bindings)!неинициализированные}-->
<p>Здесь мы видим присваивание, изменение значения переменной <code><span class="var">fact</span></code>. Это
изменение бессмысленно, если переменная <code><span class="var">fact</span></code> не существует. Глобальное
окружение можно считать местом, где уже существуют все возможные переменные.
В этой <em>виртуальной реальности</em> интерпретатор (а точнее, его часть,
ответственная за чтение программ) должен создать привязку для переменной, когда
впервые видит её имя, после чего невозмутимо продолжить работу, будто бы эта
переменная уже сто лет как здесь. Каждая переменная уже существует до своего
первого использования, а значит, её определение — это лишь изменение значения
существующей переменной. Но при таком подходе возникает проблема с получением
значения переменной, которой ещё ничего не было присвоено. Интерпретатор должен
отловить эту ошибку, когда переменная вроде как есть, но значения у неё ещё нет.
Как видите, идея привязок не так уж и проста, мы рассмотрим её подробнее
в <a href="ch04_assignment_and_side_effects.html">четвёртой главе</a>.</p>

<!--\indexC{define}-->
<p>Можно избавиться от проблем с привязками, которые существуют, но еще
не инициализированы, если принять другую позицию. Пусть изменять можно только
существующие переменные; иными словами, переменной нет, если она не была
определена явно. Для этого используется специальная форма <code><span class="special">define</span></code>,
создающая переменные. Без неё у нас не получится ни обратиться к переменной,
ни установить её значение. Однако, посмотрим теперь на это с другой стороны:</p>

<pre id="lisp1-2-omega/recusion/simple/code:redefine">(<span class="special">define</span> (<span class="func">display-pi</span>)
  (<span class="func">display</span> <span class="var">pi</span>) )
(<span class="special">define</span> <span class="var">pi</span> <span class="num">2.7182818285</span>)    <span class="comment">; ой, не та константа</span>
(<span class="special">define</span> (<span class="func">print-pi</span>)
  (<span class="func">display</span> <span class="var">pi</span>) )
(<span class="special">define</span> <span class="var">pi</span> <span class="num">3.1415926536</span>)</pre>

<p>Допустимо ли такое определение <code><span class="func">display-pi</span></code>? Её тело ссылается на <code><span class="var">pi</span></code>,
которая ещё не определена. Четвёртый <code><span class="special">define</span></code> исправляет ошибку во втором; но
даже если <code><span class="special">define</span></code> создаёт новую привязку, можно ли создать ещё одну
с таким же именем?</p>

<p>Эти вопросы не имеют однозначного ответа. Есть как минимум два варианта: считать
глобальные определения лексическими (как это делает ML) или считать их
динамическими (как это принято в Лиспе).</p>

<!--\indexR{окружение!глобальное!гиперстатическое}-->
<!--\indexR{глобальное окружение!гиперстатическое}-->
<!--\indexR{гиперстатическое окружение}-->
<p id="lisp1-2-omega/recusion/simple/par:hyperstatic">В глобальном окружении, которое
<em>полностью лексично</em> — будем называть его <em class="term">гиперстатическим</em>, — мы
не можем использовать переменную (ссылаться на неё, получать или изменять её значение), если она
не существует. В нём определение функции <code><span class="func">display-pi</span></code> будет
ошибочным, так как оно ссылается на
переменную <code><span class="var">pi</span></code>, которая не существует на момент определения. Любой вызов
функции <code><span class="func">display-pi</span></code> привёл бы к ошибке «Неизвестная переменная: <code><span class="var">pi</span></code>»
(если бы это не случилось ещё при её определении). Но с функцией <code><span class="func">print-pi</span></code>
всё в порядке, она будет выводить значение, существовавшее на момент её
определения (в данном случае это <code><span class="num">2.7182818285</span></code>), и ничто не сможет изменить
выводимое значение. Здесь переопределение <code><span class="var">pi</span></code> вполне допустимо и создаст
новую переменную <code><span class="var">pi</span></code>, которая будет использоваться в последующих выражениях
в пределах своей области видимости. Предыдущий пример можно представить примерно
таким образом:</p>

<pre>(<span class="syntax">let</span> ((<span class="var">display-pi</span> (<span class="special">lambda</span> () (<span class="func">display</span> <span class="var">pi</span>))))
  (<span class="syntax">let</span> ((<span class="var">pi</span> <span class="num">2.7182818285</span>))
    (<span class="syntax">let</span> ((<span class="var">print-pi</span> (<span class="special">lambda</span> () (<span class="func">display</span> <span class="var">pi</span>))))
      (<span class="syntax">let</span> ((<span class="var">pi</span> <span class="num">3.1415926536</span>))
        ... ) ) ) )</pre>

<p>В Лиспе, как было сказано, принят динамический подход. Предполагается, что может
существовать максимум одна глобальная переменная с уникальным именем, и эта
переменная видна везде, в том числе в своём собственном определении. Лисп
поддерживает опережающие ссылки без какого-либо специального синтаксиса. (Под
таким синтаксисом понимаются явные объявления вроде ключевого слова <code>forward</code>
Паскаля или прототипов ISO C <span class="cite">[<a href="z1_bibliography.html#iso90">ISO90</a>]</span>.)</p>

<p>Выбор отнюдь не так прост. Возвращаясь к факториалу; в окружении, где будет
вычисляться <code><span class="special">lambda</span></code>-форма, необходимо ответить на вопрос: «Чему здесь равно
значение <code><span class="var">fact</span></code>?» Если вычисление происходит в глобальном окружении, где нет
привязки для <code><span class="var">fact</span></code>, то эта функция в принципе не может быть рекурсивной.
Причина: функция ссылается на некую переменную <code><span class="var">fact</span></code>, значение которой
следует искать в окружении, захваченном замыканием (в том, которое состоит из
свободных переменных и параметров функции). Так как в момент создания замыкания
переменная <code><span class="var">fact</span></code> не существовала, то и в окружении её нет. Следовательно,
для рекурсии её необходимо каким-то образом туда добавить. Проще всего это
сделать, выбрав динамический подход к глобальному окружению, который снимает
вопрос существования переменных в принципе. При гиперстатическом же подходе надо
убедиться в том, что <code><span class="special">define</span></code> создаёт привязку для <code><span class="var">fact</span></code> перед тем, как
вычислять замыкание, которое станет значением <code><span class="var">fact</span></code>. Резюмируя: простая
рекурсия требует глобального окружения.</p>


<h3 id="lisp1-2-omega/recusion/ssect:mutual"><span class="wrap"><span class="seq">2.6.2.</span><span class="title">Взаимная рекурсия</span></span></h3>

<!--\indexR{рекурсия!взаимная}-->
<p>Теперь предположим, что мы хотим определить две взаимно рекурсивные функции.
Возьмём для примера <code><span class="func">odd?</span></code> и <code><span class="func">even?</span></code>, реализующие (весьма медленную)
проверку натуральных чисел на чётность. Они определяются следующим образом:</p>

<!--\indexC{even?}-->
<!--\indexC{odd?}-->
<!--\indexE{even?@\protect<code><span class="func">even?</span></code>|seealso{\protect<code><span class="func">odd?</span></code>}}-->
<!--\indexE{odd?@\protect<code><span class="func">odd?</span></code>|seealso{\protect<code><span class="func">even?</span></code>}}-->
<pre>(<span class="special">define</span> (<span class="func">even?</span> <span class="var">n</span>)
  (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#t</span> (<span class="func">odd?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) )
(<span class="special">define</span> (<span class="func">odd?</span> <span class="var">n</span>)
  (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#f</span> (<span class="func">even?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) )</pre>

<p>Можно менять их местами, но в любом случае первое определение не будет знать
о втором; в данном случае <code><span class="func">even?</span></code> не знает в момент определения про
<code><span class="func">odd?</span></code>. И опять, кажется, решением будет глобальное окружение с заранее
созданными переменными: оба замыкания захватывают глобальное окружение,
в котором есть все возможные переменные, среди них, в частности, и необходимые
<code><span class="func">odd?</span></code> и <code><span class="func">even?</span></code>. Конечно, мы пока оставим в стороне вопрос, как именно
реализуется захват только необходимых привязок.</p>

<p>Довольно непросто перенести это поведение в мир с гиперстатическим глобальным
окружением, так как здесь уж точно первое определение никогда не сможет узнать
о втором. Одно из решений состоит в том, чтобы определять эти две функции
одновременно, тогда не будет никаких первых и вторых, и обе функции смогут
ссылаться друг на друга без проблем. (Мы вернёмся к этому вопросу чуть позже,
после изучения локальной рекурсии.) Например, когда-то в <span class="sc">L<span class="c">isp</span> 1.5</span> имелась
форма <code><span class="special">define</span></code> с подобной возможностью:</p>


<!--\indexCS{define}{параллельные объявления}-->
<pre>(<span class="special">define</span> ((<span class="var">even?</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#t</span> (<span class="func">odd?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)))))
         (<span class="var">odd?</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#f</span> (<span class="func">even?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))))) ))</pre>

<p>Таким образом, с помощью глобального окружения и некоторых ухищрений можно
выразить и взаимную рекурсию.</p>

<p>Но что случится, если нам понадобятся локальные рекурсивные функции?</p>


<h3 id="lisp1-2-omega/recusion/ssect:local-lisp2"><span class="wrap"><span class="seq">2.6.3.</span><span class="title">Локальная рекурсия в Lisp<sub>2</sub></span></span></h3>

<!--\indexR{рекурсия!локальная}-->
<p>Некоторые проблемы, с которыми мы столкнулись при попытках определить <code><span class="func">fact</span></code>
в глобальном окружении, возвращаются при попытках определить <code><span class="func">fact</span></code> локально.
Нам надо сделать что-то, чтобы вызов <code><span class="func">fact</span></code> из тела <code><span class="func">fact</span></code> был
рекурсивным. Чтобы <code><span class="func">fact</span></code> из функционального окружения была связана
с функцией вычисления факториала даже внутри самой функции вычисления
факториала. И вот здесь как раз проявляется отличие между локальным и
глобальным окружениями: вспомните, что происходит, если искомая локальная
переменная не существует. Рассмотрим следующую программу на Lisp<sub>2</sub>:</p>

<!--\indexC{fact}-->
<pre>(<span class="special">flet</span> ((<span class="func">fact</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
                     (<span class="func">*</span> <span class="var">n</span> (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) )))
  (<span class="func">fact</span> <span class="num">6</span>) )</pre>

<p>Форма <code><span class="special">flet</span></code> связывает функцию вычисления факториала с именем <code><span class="func">fact</span></code>
в своём внутреннем функциональном окружении. Замыкание захватывает
функциональное и параметрическое окружения, локальные для формы <code><span class="special">flet</span></code>. Таким
образом, <code><span class="func">fact</span></code> внутри <code><span class="func">fact</span></code> ссылается не на функцию <code><span class="func">fact</span></code>, локальную
для тела <code><span class="special">flet</span></code>, а на какую-то другую функцию <code><span class="func">fact</span></code> из окружения всей
формы <code><span class="special">flet</span></code>. Эта функция не обязана вычислять факториал (а то и вовсе
не существует), так что рекурсию мы не получаем.</p>

<!--\indexC{label}-->
<!--\indexR{специальные формы!label@\protect<code><span class="func">label</span></code>}-->
<p>Эта проблема была очевидна ещё во времена <span class="sc">L<span class="c">isp</span> 1.5</span>. Для её решения была введена
специальная форма <code><span class="special">label</span></code>, позволявшая определять локальные рекурсивные
функции. Пример с факториалом тогда записывается так:</p>

<pre>(<span class="special">label</span> <span class="func">fact</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
                            (<span class="func">*</span> <span class="var">n</span> (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) )))</pre>

<p>Эта форма возвращает анонимную функцию, вычисляющую факториал. Более того, это
именно та функция, которая связана с <code><span class="func">fact</span></code> в своём же теле.</p>

<!--\indexC{labels}-->
<!--\indexR{специальные формы!labels@\protect<code><span class="func">labels</span></code>}-->
<p>К сожалению, нельзя сказать, что <span class="sc">L<span class="c">isp</span> 1.5</span> был Lisp<sub>2</sub>, а <code><span class="special">label</span></code>, какой бы
удобной она не была, не может легко справиться со взаимной рекурсией. Поэтому
гораздо позже, судя по <span class="cite">[<a href="z1_bibliography.html#hs75">HS75</a>]</span>, был изобретён её <span class="math"><span class="ord var">n</span></span>-арный аналог:
<code><span class="special">labels</span></code>. Эта форма имеет тот же синтаксис, что и <code><span class="special">flet</span></code>, но гарантирует,
что замыкания будут создаваться в окружении, где можно ссылаться на локальные
функции. С её помощью можно определить и <code><span class="func">fact</span></code>, и взаимно рекурсивные
<code><span class="func">odd?</span></code> и <code><span class="func">even?</span></code>:</p>

<pre>(<span class="special">labels</span> ((<span class="func">fact</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
                       (<span class="func">*</span> <span class="var">n</span> (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) )))
  (<span class="func">fact</span> <span class="num">6</span>) ) <span class="math"><span class="rel">→</span></span> <span class="num">720</span>

(<span class="func">funcall</span> (<span class="special">labels</span> ((<span class="func">even?</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#t</span> (<span class="func">odd?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))))
                  (<span class="func">odd?</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#f</span> (<span class="func">even?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)))) )
           (<span class="special">function</span> <span class="var">even?</span>) )
         <span class="num">4</span> ) <span class="math"><span class="rel">→</span></span> <span class="hash">#t</span></pre>

<p>Так что в Lisp<sub>2</sub> мы имеем две формы для расширения локального функционального
окружения: <code><span class="special">flet</span></code> и <code><span class="special">labels</span></code>.</p>


<h3 id="lisp1-2-omega/recusion/ssect:local-lisp1"><span class="wrap"><span class="seq">2.6.4.</span><span class="title">Локальная рекурсия в Lisp<sub>1</sub></span></span></h3>

<!--\indexR{рекурсия!локальная}-->
<p>Проблема определения локальных рекурсивных функций существует и в Lisp<sub>1</sub>;
решается она похожим способом. Форма <code><span class="syntax">letrec</span></code> (рекурсивная <code><span class="syntax">let</span></code>) очень
похожа по смыслу на <code><span class="special">labels</span></code>.</p>

<p>В Scheme <code><span class="syntax">let</span></code> имеет следующий синтаксис:</p>

<pre>(<span class="syntax">let</span> ((<i>переменная<sub>1</sub></i> <i>выражение<sub>1</sub></i>)
      (<i>переменная<sub>2</sub></i> <i>выражение<sub>2</sub></i>)
       ...
      (<i>переменная<sub>n</sub></i> <i>выражение<sub>n</sub></i>) )
  <i>выражения</i>... )</pre>

<!--\indexC{let}-->
<p class="noindent">И она эквивалентна такому выражению:</p>

<pre>((<span class="special">lambda</span> (<i>переменная<sub>1</sub></i> <i>переменная<sub>2</sub></i> ... <i>переменная<sub>n</sub></i>) <i>выражения</i>...)
 <i>выражение<sub>1</sub></i> <i>выражение<sub>2</sub></i> ... <i>выражение<sub>n</sub></i> )</pre>

<p>Поясним, что здесь происходит. Сперва вычисляются все аргументы аппликации:
<i>выражение<sub>1</sub></i>, <i>выражение<sub>2</sub></i>, …, <i>выражение<sub>n</sub></i>;
затем переменные <i>переменная<sub>1</sub></i>, <i>переменная<sub>2</sub></i>, …,
<i>переменная<sub>n</sub></i> связываются с только что полученными значениями;
наконец, <i>выражения</i>, составляющие тело <code><span class="syntax">let</span></code>, вычисляются в расширенном
окружении внутри неявной формы <code><span class="special">begin</span></code>, а её значение становится значением
всей формы <code><span class="syntax">let</span></code>.</p>

<p>Как видим, в принципе нет необходимости делать <code><span class="syntax">let</span></code> специальной формой, так
как её полностью заменяет <code><span class="special">lambda</span></code>; следовательно, <code><span class="syntax">let</span></code> может быть всего
лишь макросом. (Именно так и поступили в Scheme: <code><span class="syntax">let</span></code> — это встроенный
макрос.) Тем не менее, <code><span class="syntax">let</span></code> хороша с точки зрения стиля кодирования, потому
что позволяет не разделять имя переменной и её начальное значение большим куском
кода. Теперь самое время заметить, что начальные значения локальных переменных
формы <code><span class="syntax">let</span></code> вычисляются в текущем окружении; в расширенном вычисляется только
её тело.</p>

<!--\indexC{letrec}-->
<p>По тем же причинам, с которыми мы столкнулись в Lisp<sub>2</sub>, это значительно
усложняет написание взаимно рекурсивных функций. Поэтому вводится форма
<code><span class="syntax">letrec</span></code>, аналог <code><span class="special">labels</span></code>.</p>

<p>Синтаксис <code><span class="syntax">letrec</span></code> такой же, как и у <code><span class="syntax">let</span></code>. Например:</p>

<pre>(<span class="syntax">letrec</span> ((<span class="var">even?</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#t</span> (<span class="func">odd?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)))))
         (<span class="var">odd?</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#f</span> (<span class="func">even?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))))) )
  (<span class="func">even?</span> <span class="num">4</span>) )</pre>

<!--\indexCS{letrec}{как макрос}-->
<p>Отличается <code><span class="syntax">letrec</span></code> от <code><span class="syntax">let</span></code> тем, что выражения-инициализаторы
вычисляются в том же окружении, что и тело <code><span class="syntax">letrec</span></code>. Операции, которые
выполняет <code><span class="syntax">letrec</span></code>, те же, что и у <code><span class="syntax">let</span></code>, но их порядок несколько иной.
Сначала локальное окружение расширяется переменными
<code><span class="syntax">letrec</span></code>. Затем в этом
расширенном окружении вычисляются начальные значения переменных. Наконец,
в том же расширенном окружении вычисляется тело <code><span class="syntax">letrec</span></code>. По этому описанию
довольно легко понять, как реализовать такое поведение. Действительно,
достаточно написать следующее:</p>

<!--\indexC{even"?}-->
<!--\indexC{odd"?}-->
<!--\indexC*{void}{'void}-->
<pre>(<span class="syntax">let</span> ((<span class="var">even?</span> '<span class="var">void</span>) (<span class="var">odd?</span> '<span class="var">void</span>))
  (<span class="special">set!</span> <span class="var">even?</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#t</span> (<span class="func">odd?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)))))
  (<span class="special">set!</span> <span class="var">odd?</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#f</span> (<span class="func">even?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)))))
  (<span class="func">even?</span> <span class="num">4</span>) )</pre>

<p>Сначала создаются привязки для <code><span class="var">even?</span></code> и <code><span class="var">odd?</span></code>. (Их начальные значения
не важны, просто <code><span class="syntax">let</span></code> и <code><span class="special">lambda</span></code> требуют какое-то значение.) Затем эти
переменные инициализируются значениями, вычисленными в окружении, где известны
переменные <code><span class="var">even?</span></code> и <code><span class="var">odd?</span></code>. Мы говорим «известны», потому что хотя для
этих переменных и созданы привязки, их значения не имеют смысла, так как они
ещё не были правильно инициализированы. Про <code><span class="var">even?</span></code> и <code><span class="var">odd?</span></code> известно
достаточно, чтобы ссылаться на них, но пока ещё недостаточно, чтобы они
участвовали в вычислениях.</p>

<!--\indexR{порядок вычислений!неопределённый}-->
<p>Однако, такое преобразование не совсем корректно из-за порядка вычислений:
действительно, <code><span class="syntax">let</span></code> раскрывается в применение функции, следовательно,
<code><span class="syntax">letrec</span></code>, по идее, должна вести себя так же, а это значит, что начальные
значения переменных должны вычисляться как аргументы функции — то есть
в неопределённом порядке. К сожалению, подобный вариант всегда вычисляет их
слева направо.
<span class="see">[см. упр. <a href="#lisp1-2-omega/ex:orderless-letrec">2.9</a>]</span></p>

<h4><span class="wrap"><span class="title">Уравнения и <code><span class="syntax">letrec</span></code></span></span></h4>


<!--\indexCS{letrec}{и уравнения}-->
<p>С формой <code><span class="syntax">letrec</span></code> есть ещё одна серьёзная проблема: её синтаксис не является
строгим. При текущей трактовке <code><span class="syntax">letrec</span></code> допускает в качестве инициализаторов
всё что угодно, не только функции; тогда как <code><span class="special">labels</span></code> в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>
разрешает определять исключительно функции. То есть в Scheme теоретически можно
будет написать следующее:</p>

<pre>(<span class="syntax">letrec</span> ((<span class="var">x</span> (<span class="func">/</span> (<span class="func">+</span> <span class="var">x</span> <span class="num">1</span>) <span class="num">2</span>))) <span class="var">x</span>)</pre>

<p>Заметьте, что переменная <code><span class="var">x</span></code> фактически определяется через саму себя. Это,
похоже, обыкновенное уравнение</p>

<blockquote class="equation math"><span class="ord var">x</span><span class="rel">=</span><div class="frac ord"><div class="numerator"><span class="ord var">x</span><span class="binop">+</span><span class="ord num">1</span></div><div class="denominator"><span class="ord num">2</span></div></div></blockquote>

<p>Логично будет сделать значением <code><span class="var">x</span></code> корень этого уравнения. То есть такое
выражение должно вернуть <code><span class="num">1</span></code>.</p>

<p>Но что делать, если у уравнения нет корней или если их несколько?</p>

<pre>(<span class="syntax">letrec</span> ((<span class="var">x</span> (<span class="func">+</span> <span class="var">x</span> <span class="num">1</span>))) <span class="var">x</span>)            <span class="comment">; <span class="math"><span class="ord var">x</span><span class="rel">=</span><span class="ord var">x</span><span class="binop">+</span><span class="num ord">1</span></span></span>
(<span class="syntax">letrec</span> ((<span class="var">x</span> (<span class="func">+</span> (<span class="func">power</span> <span class="var">x</span> <span class="num">37</span>) <span class="num">1</span>))) <span class="var">x</span>) <span class="comment">; <span class="math"><span class="ord var">x</span><span class="rel">=</span><span class="ord var">x</span><sup><span class="ord num">37</span></sup><span class="binop">+</span><span class="ord num">1</span></span></span></pre>

<p>Однако, существуют множества, вроде известного вам множества S-выражений, где
достаточно легко убедиться в том, что уравнение имеет единственное решение
<span class="cite">[<a href="z1_bibliography.html#ms80">MS80</a>]</span>. Например, следующим образом можно без побочных эффектов определить
бесконечный список — как корень данного «списочного» уравнения:</p>

<pre>(<span class="syntax">letrec</span> ((<span class="var">foo</span> (<span class="func">cons</span> '<span class="var">bar</span> <span class="var">foo</span>))) <span class="var">foo</span>)</pre>

<!--\indexR{ленивые вычисления}-->
<p>Значением этого выражения может быть или лениво вычисляемый бесконечный
список <code>(<span class="var">bar</span> <span class="var">bar</span> <span class="var">bar</span> ...)</code>, как это сделано в <span class="cite">[<a href="z1_bibliography.html#fw76">FW76</a>,
<a href="z1_bibliography.html#pj87">PJ87</a>]</span>, так и
закольцованная структура данных (менее дорогая с вычислительной точки зрения):</p>

<pre>(<span class="syntax">let</span> ((<span class="var">foo</span> (<span class="func">cons</span> '<span class="var">bar</span> '<span class="var">wait</span>)))
  (<span class="func">set-cdr!</span> <span class="var">foo</span> <span class="var">foo</span>)
  <span class="var">foo</span> )</pre>

<p>Эффективно это одно и то же, но на самом деле нет. В общем, из-за всех этих
неоднозначностей стоит ввести правило, запрещающее использовать переменную,
определяемую <code><span class="syntax">letrec</span></code>, для определения значения этой же переменной. В двух
предыдущих примерах необходимо было знать значение <code><span class="var">x</span></code> для того чтобы
инициализировать <code><span class="var">x</span></code>. Теперь они, очевидно, являются ошибочными. Однако мы
помним, что порядок инициализации в Scheme должен быть неопределённым, а значит,
некоторые конструкции, допускаемые данным правилом, могут быть ошибочными
в одних реализациях, но работать в других. Рассмотрим следующий пример:</p>

<pre>(<span class="syntax">letrec</span> ((<span class="var">x</span> (<span class="func">+</span> <span class="var">y</span> <span class="num">1</span>))
         (<span class="var">y</span> <span class="num">2</span>) )
  <span class="var">x</span> )</pre>

<p>Если <code><span class="var">y</span></code> инициализируется до <code><span class="var">x</span></code>, то всё в порядке. В противном случае
возникает ошибка, потому что мы хотим увеличить значение переменной <code><span class="var">y</span></code>,
которая уже существует, но ещё не имеет значения. Некоторые компиляторы Scheme
и ML анализируют выражения-инициализаторы и проводят топологическую сортировку
для определения подходящего порядка инициализации. Естественно, такое решение
тоже не всегда срабатывает; в частности, при взаимной зависимости<a class="footref"
href="zz_footnotes.html#foot2.9"><sup>9</sup></a> вроде такой:</p>

<pre>(<span class="syntax">letrec</span> ((<span class="var">x</span> <span class="var">y</span>) (<span class="var">y</span> <span class="var">x</span>)) (<span class="func">list</span> <span class="var">x</span> <span class="var">y</span>))</pre>

<p>Рассмотренные примеры напоминают о нашей дискуссии вокруг глобального окружения
и семантики <code><span class="special">define</span></code>. Там возникла похожая проблема: что делать
с неинициализированными привязками и как узнать о том, что они вообще
существуют.</p>


<h3 id="lisp1-2-omega/recusion/ssect:uninitialized"><span class="wrap"><span class="seq">2.6.5.</span><span class="title">Объявление неинициализированных привязок</span></span></h3>

<!--\indexR{привязки (bindings)!неинициализированные}-->
<p>Официально семантика Scheme считает <code><span class="syntax">letrec</span></code> производной формой; то есть
удобным, но отнюдь не обязательным сокращением. Соответственно, любую
<code><span class="syntax">letrec</span></code>-форму можно переписать с помощью примитивных форм Scheme. Чуть
раньше мы попробовали это сделать, временно связывая переменные <code><span class="syntax">letrec</span></code>
со значением <code><span class="var">void</span></code>. К сожалению, это тоже инициализация, так что обращения
к неинициализированным переменным подобным образом отловить нельзя. Наша
ситуация усугубляется тем, что ни одна из четырёх специальных форм Scheme
не позволяет создавать «родные» неинициализированные привязки.</p>

<!--\indexC*{UFO}{\#<UFO>}-->
<p>В первом приближении можно было бы решить проблему, используя некий объект
<code><span class="hash">#&lt;UFO&gt;</span></code>
<span class="see">[см. раздел <a href="ch01_basics.html#basics/s:env/ufo">1.5</a>]</span>
вместо <code><span class="var">void</span></code>. С ним ничего нельзя
сделать: ни прибавить к нему число, ни взять его <code><span class="func">car</span></code>; однако, это всё же
полноценный объект, так что его можно передать как аргумент в <code><span class="func">cons</span></code>, а
значит, следующая программа не будет ошибочной и вернёт <code><span class="hash">#&lt;UFO&gt;</span></code>:</p>

<pre>(<span class="syntax">letrec</span> ((<span class="var">foo</span> (<span class="func">cons</span> '<span class="var">foo</span> <span class="var">foo</span>))) (<span class="func">cdr</span> <span class="var">foo</span>))</pre>

<p>Причина такого поведения в том, что неинициализированность — это свойство
самой привязки, а не её значения. Следовательно, мы не сможем решить проблему,
используя объекты первого класса.</p>

<!--\indexC*{uninitialized}{\#<uninitialized>}-->
<p>И всё же, многие реализации дают неинициализированным переменным специальное
значение. Давайте назовём его <code><span class="hash">#&lt;uninitialized&gt;</span></code> и предположим, что это
полноценный объект. Любая переменная с таким значением считается
неинициализированной. Следовательно, используя вместо <code><span class="var">void</span></code> значение
<code><span class="hash">#&lt;uninitialized&gt;</span></code>, мы получаем желаемую возможность обнаружить ошибку.
Однако, эта возможность чересчур явная: ничто не запрещает передавать
<code><span class="hash">#&lt;uninitialized&gt;</span></code> в функцию как аргумент, а значит, больше нельзя
предполагать, что все аргументы функции имеют значения. Мы будем вынуждены
каждый раз проверять, действительно ли это так:</p>

<pre>(<span class="special">define</span> (<span class="func">fact</span> <span class="var">n</span>)
  (<span class="special">if</span> (<span class="func">eq?</span> <span class="var">n</span> '<span class="hash">#&lt;uninitialized&gt;</span>)
      (<span class="func">wrong</span> <span class="string">"Uninitialized n"</span>)
      (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
          (<span class="func">*</span> <span class="var">n</span> (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) ) )</pre>

<p>Делать так со всеми переменными — это слишком большая плата за <code><span class="syntax">letrec</span></code>.
Так что <code><span class="hash">#&lt;uninitialized&gt;</span></code> нельзя делать полноценным объектом, это должно
быть особое внутреннее значение интерпретатора, которое нельзя использовать
в программах. Для того, чтобы им можно было пользоваться безопасно, необходим
специальный синтаксис.</p>

<p>Третий вариант решения состоит во введении специальной формы, создающей
неинициализированные привязки. Например, перенесём синтаксис <code><span class="special">let</span></code> из
<span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>, выполняющей данное действие, в Scheme:</p>

<pre>(<span class="special">let</span> (<i>переменная</i> ...)
  ... )</pre>

<p>Если имя переменной указано само по себе, без начального значения, то привязка
к этому имени не будет инициализирована. Если нам понадобится её значение, то мы
будем вынуждены проверять, была ли инициализирована данная переменная или нет.
Теперь можно будет написать нормальную реализацию <code><span class="syntax">letrec</span></code>.
В следующем коде переменные <i>temp<sub>i</sub></i> являются «гигиеничными»: им выдаются
специальные имена, гарантированно не конфликтующие с именами переменных
<code><span class="syntax">letrec</span></code> или
свободными переменными её тела.</p>

<table class="nocaption code"><tbody><tr>
<td><pre>(<span class="syntax">letrec</span> ((<i>имя<sub>1</sub></i> <i>выражение<sub>1</sub></i>)
         ...
         (<i>имя<sub>n</sub></i> <i>выражение<sub>n</sub></i>) )
  <i>тело</i> )</pre></td>
<td><span class="math"><span class="rel">≡</span><span class="ord"></span></span></td>
<td><pre>(<span class="special">let</span> (<i>имя<sub>1</sub></i> ... <i>имя<sub>n</sub></i>)
  (<span class="special">let</span> ((<i>temp<sub>1</sub></i> <i>выражение<sub>1</sub></i>)
        ...
        (<i>temp<sub>n</sub></i> <i>выражение<sub>n</sub></i>) )
  (<span class="special">set!</span> <i>имя<sub>1</sub></i> <i>выражение<sub>1</sub></i>)
  ...
  (<span class="special">set!</span> <i>имя<sub>n</sub></i> <i>выражение<sub>n</sub></i>)
  <i>тело</i> ) )</pre></td>
</tr></tbody></table>

<!--\indexCS{let}{специальная форма}-->
<p>Итого, проблема решена с приемлемой эффективностью: лишь неинициализированные
переменные вызывают накладные расходы, потому что за особенности надо платить.
Но теперь форма <code><span class="special">let</span></code> не является просто синтаксическим сахаром, теперь это
полноценная специальная форма, которую должен обрабатывать лично интерпретатор.
Добавляем соответствующий код в <code><span class="func">evaluate</span></code>:</p>

<pre>...
((<span class="var">let</span>)
 (<span class="func">eprogn</span> (<span class="func">cddr</span> <span class="var">e</span>)
         (<span class="func">extend</span> <span class="var">env</span>
                 (<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">binding</span>)
                        (<span class="special">if</span> (<span class="func">symbol?</span> <span class="var">binding</span>) <span class="var">binding</span>
                            (<span class="func">car</span> <span class="var">binding</span>) ) )
                      (<span class="func">cadr</span> <span class="var">e</span>) )
                 (<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">binding</span>)
                        (<span class="special">if</span> (<span class="func">symbol?</span> <span class="var">binding</span>) <span class="var">the-uninitialized-marker</span>
                            (<span class="func">evaluate</span> (<span class="func">cadr</span> <span class="var">binding</span>) <span class="var">env</span>) ) )
                      (<span class="func">cadr</span> <span class="var">e</span>) ) ) ) ) ...</pre>

<p>Переменная <code><span class="var">the-uninitialized-marker</span></code> принадлежит языку определения. Зададим
её, например, так:</p>

<!--\indexC{the-uninitialized-marker}-->
<pre>(<span class="special">define</span> <span class="var">the-uninitialized-marker</span> (<span class="func">cons</span> '<span class="var">not</span> '<span class="var">initialized</span>))</pre>

<p>Конечно, теперь необходимо встроить поддержку этого внутреннего значения
в функцию <code><span class="func">lookup</span></code>. Функция <code><span class="func">update!</span></code> в изменениях не нуждается по
очевидным причинам. Обращения к <code><span class="func">wrong</span></code> отвечают за два различных типа
ошибок: несуществующую привязку и неинициализированную привязку.</p>

<!--\indexC{lookup}-->
<pre>(<span class="special">define</span> (<span class="func">lookup</span> <span class="var">id</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">env</span>)
      (<span class="special">if</span> (<span class="func">eq?</span> (<span class="func">caar</span> <span class="var">env</span>) <span class="var">id</span>)
          (<span class="syntax">let</span> ((<span class="var">value</span> (<span class="func">cdar</span> <span class="var">env</span>)))
            (<span class="special">if</span> (<span class="func">eq?</span> <span class="var">value</span> <span class="var">the-uninitialized-marker</span>)
                (<span class="func">wrong</span> <span class="string">"Uninitialized binding"</span> <span class="var">id</span>)
                <span class="var">value</span> ) )
          (<span class="func">lookup</span> <span class="var">id</span> (<span class="func">cdr</span> <span class="var">env</span>)) )
      (<span class="func">wrong</span> <span class="string">"No such binding"</span> <span class="var">id</span>) ) )</pre>

<p>После блужданий по пустыне семантики и синтаксиса, у нас наконец-то получилась
форма <code><span class="syntax">letrec</span></code>, позволяющая определять локальные взаимно рекурсивные функции.</p>


<h3 id="lisp1-2-omega/recusion/ssect:no-assignment"><span class="wrap"><span class="seq">2.6.6.</span><span class="title">Рекурсия без присваивания</span></span></h3>

<!--\indexR{язык!чисто функциональный}-->
<!--\indexR{рекурсия!без присваивания}-->
<p>Форма <code><span class="syntax">letrec</span></code>, которую мы рассматривали, использует присваивания для
обеспечения правильного вычисления начальных значений. Языки, называемые
<em>чисто функциональными</em>, не имеют в своём распоряжении операторов
присваивания; в них принципиально нет побочных эффектов, а чем, как
не побочным эффектом вычислений, является изменение значения переменной?</p>

<p>В качестве парадигмы программирования запрет на присваивание имеет свои
преимущества: он гарантирует сохранение ссылочной прозрачности и этим
развязывает руки множеству оптимизаций, позволяя перемещать и распараллеливать
части программ, использовать ленивые вычисления и т. д. Однако, если нет
возможности использовать присваивания, то некоторые алгоритмы становятся
не такими простыми, а также несколько усложняется перенос программ на реальные
компьютеры, так как побочные эффекты являются неотъемлемой частью их работы.</p>


<!--\indexC{letrec}-->
<p>Первое, что приходит в голову, это сделать <code><span class="special">letrec</span></code> ещё одной специальной
формой, как это и сделано в ML и подобных ему языках. Модифицируем <code><span class="func">evaluate</span></code>
для обработки этого случая:</p>

<pre>...
((<span class="var">letrec</span>)
 (<span class="syntax">let</span> ((<span class="var">new-env</span> (<span class="func">extend</span> <span class="var">env</span>
                        (<span class="func">map</span> <span class="var">car</span> (<span class="func">cadr</span> <span class="var">e</span>))
                        (<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">binding</span>) <span class="var">the-uninitialized-marker</span>)
                             (<span class="func">cadr</span> <span class="var">e</span>) ) )))
      (<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">binding</span>)         <span class="comment">; <code><span class="func">map</span></code> во имя беспорядка!</span>
             (<span class="func">update!</span> (<span class="func">car</span> <span class="var">binding</span>)
                      <span class="var">new-env</span>
                      (<span class="func">evaluate</span> (<span class="func">cadr</span> <span class="var">binding</span>) <span class="var">new-env</span>) ) )
           (<span class="func">cadr</span> <span class="var">e</span>) )
      (<span class="func">eprogn</span> (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">new-env</span>) ) ) ...</pre>

<p>В этом случае побочные эффекты всё равно присутствуют, но на уровне
интерпретатора, внутри <code><span class="func">update!</span></code>; с точки зрения определяемого языка побочных
эффектов нет. Стоит заметить, что мы намеренно не указываем порядок вычислений,
используя <code><span class="func">map</span></code>, которая, в отличие от <code><span class="func">for-each</span></code>, вольна обрабатывать
список в любом удобном порядке.<a class="footref" href="zz_footnotes.html#foot2.10"><sup>10</sup></a></p>


<h4><span class="wrap"><span class="title"><code><span class="syntax">letrec</span></code> и полностью лексическое глобальное окружение</span></span></h4>

<p>В гиперстатическом глобальном окружении переменную можно использовать только
после того, как она была определена. С такими ограничениями мы не можем легко
определять ни взаимно, ни даже просто рекурсивные функции. Форма <code><span class="func">letrec</span></code>
решает эту проблему, а заодно служит индикатором рекурсивных определений.</p>

<pre>(<span class="syntax">letrec</span> ((<span class="var">fact</span> (<span class="special">lambda</span> (<span class="var">n</span>)
                 (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span> (<span class="func">*</span> <span class="var">n</span> (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)))) )))
  (<span class="syntax">letrec</span> ((<span class="var">odd?</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#f</span> (<span class="func">even?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)))))
           (<span class="var">even?</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#t</span> (<span class="func">odd?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))))) )
    ... ) )</pre>

<p class="noindent">В данном случае <code><span class="syntax">letrec</span></code> создаёт опережающие ссылки на <code><span class="var">fact</span></code>, <code><span class="var">odd?</span></code>
и <code><span class="var">even?</span></code>, так что определения будут работать и в гиперстатическом окружении.</p>


<h4><span class="wrap"><span class="title">Парадоксальный комбинатор</span></span></h4>

<!--\indexR{комбинаторы!неподвижной точки}-->
<!--\indexR{комбинаторы!Y@\protect\comb{Y}}-->
<!--\indexE{Y@\protect\comb{Y}, комбинатор}-->
<!--\indexR{теорема о неподвижной точке}-->
<!--\indexR{неподвижная точка}-->
<!--\indexR{лямбда-исчисление@<span class="math"><span class="ord var">λ</span></span>-исчисление!комбинаторы}-->
<p>Если вы имели дело с <span class="math"><span class="ord var">λ</span></span>-исчислением, то вы наверняка помните, что
такое <em>комбинаторы неподвижной точки</em> и как записывается самый известный
из них — <em>парадоксальный</em> или Y-комбинатор. Функция
<span class="math"><span class="ord var">f</span></span> имеет
неподвижную точку, если в её области определения существует элемент
<span class="math"><span class="ord var">x</span></span> такой,
что <span class="math"><span class="ord var">f</span><span class="open">(</span><span class="ord var">x</span><span class="close">)</span><span class="rel">=</span><span class="ord var">x</span></span>.
Комбинатор <span class="comb">Y</span> принимает любую функцию
<span class="math"><span class="ord var">λ</span></span>-исчисления и возвращает её неподвижную точку. Эта идея выражена
в одной из наиболее прекрасных и содержательных теорем <span class="math"><span class="ord var">λ</span></span>-исчисления:</p>

<blockquote class="theorem"><span class="title">Теорема о неподвижной точке:</span>
<span class="math"><span class="ord">∃</span><span class="ord comb">Y</span><span class="ord">: </span><span class="ord">∀</span><span class="ord var">F</span><span class="ord">: </span><span class="ord comb">Y</span><span class="ord var">F</span><span class="rel">=</span><span class="open">(</span><span class="ord comb">Y</span><span class="ord var">F</span><span class="close">)</span></span></blockquote>

<p>В терминах Лиспа, <span class="comb">Y</span> — это значение выражения</p>

<pre>(<span class="syntax">let</span> ((<span class="var">W</span> (<span class="special">lambda</span> (<span class="var">w</span>)
           (<span class="special">lambda</span> (<span class="var">f</span>)
             (<span class="func">f</span> ((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>)) ) )))
  (<span class="func">W</span> <span class="var">W</span>) )</pre>

<p>Доказать это весьма просто. Если предположить, что <span class="comb">Y</span> равен <span class="math"><span class="open">(</span><span class="ord var">W</span><span class="ord var">W</span><span class="close">)</span></span>, то какой должна быть <span class="math"><span class="ord var">W</span></span>, чтобы <span class="math"><span class="open">(</span><span class="ord var">W</span><span class="ord var">W</span><span class="close">)<span class="ord var">F</span></span></span> равнялось <span class="math"><span class="open"><span class="ord var">F</span>(</span><span class="ord var">W</span><span class="ord var">W</span><span class="close">)<span class="ord var">F</span></span></span>?

Очевидно, что функция <span class="ord var">W</span> должна быть ничем иным, как <span class="math"><span class="ord var">λ</span><span class="ord var">W</span><span class="ord">.</span><span class="ord var">λ</span><span class="ord var">F</span><span class="ord">.</span><span class="ord var">F</span><span class="open">(</span><span class="open">(</span><span class="ord var">W</span><span class="ord var">W</span><span class="close">)</span><span class="ord var">F</span><span class="close">)</span></span>. Приведённое выражение лишь записывает эту идею на Лиспе.</p>

<!--\indexR{комбинаторы!Z@\protect\comb{Z}}-->
<!--\indexE{Z@\protect\comb{Z}, комбинатор}-->
<!--\indexR{эта-конверсия@$\eta$-конверсия}-->
<p>Правда, здесь возникает небольшое затруднений из-за принятой в Scheme передачи
аргументов по значению. Терм <code>((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>)</code> не следует вычислять слишком рано,
поэтому мы вынуждены добавить излишнюю (в <span class="math"><span class="ord var">λ</span></span>-исчислении) <span class="math"><span class="ord var">η</span></span>-конверсию, чтобы избежать проблем.
В итоге мы приходим к так называемому Z-комбинатору, где <code>(<span class="special">lambda</span> (<span class="var">x</span>) (... <span class="var">x</span>))</code> означает <span class="math"><span class="ord var">η</span></span>-конверсию:</p>

<!--\indexC{fix}-->
<pre>(<span class="special">define</span> <span class="var">fix</span>
  (<span class="syntax">let</span> ((<span class="var">d</span> (<span class="special">lambda</span> (<span class="var">w</span>)
             (<span class="special">lambda</span> (<span class="var">f</span>)
               (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>) (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>))) ) )))
  (<span class="func">d</span> <span class="var">d</span>) ) )</pre>

<p>Самое сложное в этом определении — понять, как оно работает. Сейчас мы этим
и займёмся. Определим функцию <code><span class="func">meta-fact</span></code>:</p>

<!--\indexC{meta-fact}-->
<pre id="lisp1-2-omega/recursion/y-combinator/code:meta-fact">(<span class="special">define</span> (<span class="func">meta-fact</span> <span class="var">f</span>)
  (<span class="special">lambda</span> (<span class="var">n</span>)
    (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
        (<span class="func">*</span> <span class="var">n</span> (<span class="func">f</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) ) )</pre>

<p>Эта функция подозрительно похожа на факториал. Проверив, мы убеждаемся, что
<code>(<span class="func">meta-fact</span> <span class="func">fact</span>)</code> вычисляет факториал с таким же успехом, что и <code><span class="func">fact</span></code>,
разве что несколько медленнее. Теперь предположим, что мы знаем неподвижную
точку <span class="math"><span class="ord var">f</span></span> функции <code><span class="func">meta-fact</span></code>: <span class="math"><span class="ord var">f</span><span class="rel">=</span><code class="ord">(<span class="func">meta-fact</span> <span class="math"><span class="ord var">f</span></span>)</code></span>. Эта
неподвижная точка по определению является решением следующего функционального
уравнения относительно <span class="math"><span class="ord var">f</span></span>:</p>

<pre><span class="math"><span class="ord var">f</span></span> = (<span class="special">lambda</span> (<span class="var">n</span>)
      (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
          (<span class="func">*</span> <span class="var">n</span> (<span class="math"><span class="ord var">f</span></span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) )</pre>

<p>Итак, что же такое <span class="math"><span class="ord var">f</span></span>? Не что иное, как всем известный факториал!</p>

<p>Вообще-то говоря, нет ни единого основания полагать, что уравнение выше имеет
решение и что оно единственно. (Конечно, эти термины надо бы определить строго
математически, но это выходит за рамки данной книги.) Действительно, есть как
минимум ещё одно решение:</p>

<!--\indexC{fact}-->
<pre>(<span class="special">define</span> (<span class="func">another-fact</span> <span class="var">n</span>)
  (<span class="syntax">cond</span> ((<span class="func">&lt;</span> <span class="var">n</span> <span class="num">1</span>) (<span class="func">-</span> <span class="var">n</span>))
        ((<span class="func">=</span> <span class="var">n</span> <span class="num">1</span>) <span class="num">1</span>)
        (<span class="syntax">else</span> (<span class="func">*</span> <span class="var">n</span> (<span class="func">another-fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)))) ) )</pre>

<!--\indexR{неподвижная точка!наименьшая}-->
<p>Проверьте, пожалуйста, что <code><span class="func">another-fact</span></code> также является неподвижной точкой
<code><span class="func">meta-fact</span></code>. Анализируя возможные неподвижные точки, можно прийти к выводу,
что есть такая область определения, на которой их значения совпадают: все они
вычисляют факториал натуральных чисел. Их поведение различно только тогда, когда
исходный вариант <code><span class="func">fact</span></code> попадает в бесконечный цикл. Для отрицательных целых
чисел <code><span class="func">another-fact</span></code> возвращает одно значение, хотя вполне могла бы вернуть
какое-нибудь другое, потому что исходное функциональное уравнение не указывает,<a class="footref" href="zz_footnotes.html#foot2.11"><sup>11</sup></a> что делать в таком
случае. Если упорядочить функции по некоторой мере их определённости, то должна
существовать наименьшая неподвижная точка — наименее определённое решение
функционального уравнения.</p>

<p>Математический смысл глобальных рекурсивных определений вроде <code><span class="func">fact</span></code> состоит
в том, что они определяют функции, являющиеся наименьшими неподвижными точками
соответствующих функциональных уравнений. Когда мы пишем:</p>

<pre>(<span class="special">define</span> (<span class="func">fact</span> <span class="var">n</span>)
  (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
      (<span class="func">*</span> <span class="var">n</span> (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) )</pre>

<p class="noindent">то фактически записываем уравнение относительно переменной <code><span class="var">fact</span></code>. Форма
<code><span class="special">define</span></code> решает это уравнение и связывает полученное решение
с переменной <code><span class="var">fact</span></code>. Такая трактовка уводит нас далеко от обсуждения
инициализации глобальных переменных
<span class="see">[см. раздел <a href="#lisp1-2-omega/recusion/ssect:simple">2.6.1</a>]</span>
и превращает <code><span class="special">define</span></code> в магический решатель уравнений. В действительности,
<code><span class="special">define</span></code> реализована именно так, как предложено ранее. Просто рекурсия
в глобальном окружении вместе с нормальным порядком вычислений действительно
способны находить наименьшие неподвижные точки.</p>

<p>А теперь вернёмся к <code><span class="func">fix</span></code>, нашему Z-комбинатору, и проследим, как же
вычисляется <code>((<span class="func">fix</span> <span class="func">meta-fact</span>) <span class="num">3</span>)</code>. Помните, что здесь функции не имеют
побочных эффектов, а значит, результаты вычислений можно свободно подставлять
друг в друга, чем мы и будем пользоваться.</p>

<!--\indexC{fix}-->
<pre>((<span class="func">fix</span> <span class="func">meta-fact</span>) <span class="num">3</span>)
<span class="math"><span class="rel">≡</span></span> (((<span class="func">d</span> <span class="var">d</span>)<div class="where"><div class="wrap">
<span class="var">d</span> <span class="math"><span class="rel">≡</span></span></div> <div class="complex">(<span class="special">lambda</span> (<span class="var">w</span>)
  (<span class="special">lambda</span> (<span class="var">f</span>)
    (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
         (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) ) )</div></div>
    <span class="var">meta-fact</span> )
   <span class="num">3</span> )

<span class="math"><span class="rel">≡</span></span> (((<span class="special">lambda</span> (<span class="var">f</span>)               <span class="comment">; <em class="term">шаг I</em></span>
      (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
           (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) )<div class="where"><div class="wrap">
<span class="var">w</span> <span class="math"><span class="rel">≡</span></span></div> <div class="complex">(<span class="special">lambda</span> (<span class="var">w</span>)
  (<span class="special">lambda</span> (<span class="var">f</span>)
    (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
         (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) ) )</div></div>
    <span class="var">meta-fact</span> )
   <span class="num">3</span> )

<span class="math"><span class="rel">≡</span></span> ((<span class="func">meta-fact</span> (<span class="special">lambda</span> (<span class="var">x</span>)
                (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) ))<div class="where"><div class="wrap">
<span class="var">w</span> <span class="math"><span class="rel">≡</span></span></div> <div class="complex">(<span class="special">lambda</span> (<span class="var">w</span>)
  (<span class="special">lambda</span> (<span class="var">f</span>)
    (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
         (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) ) )</div></div>
   <span class="num">3</span> )

<span class="math"><span class="rel">≡</span></span> ((<span class="special">lambda</span> (<span class="var">n</span>)
     (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
         (<span class="func">*</span> <span class="var">n</span> (<span class="func">f</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) )<div class="where"><div class="wrap">
<span class="var">f</span> <span class="math"><span class="rel">≡</span></span></div> <div class="complex">(<span class="special">lambda</span> (<span class="var">x</span>)
  (((<span class="func">w</span> <span class="var">w</span>) <span class="var">meta-fact</span>) <span class="var">x</span>) )<div class="where"><div class="wrap">
<span class="var">w</span> <span class="math"><span class="rel">≡</span></span></div> <div class="complex">(<span class="special">lambda</span> (<span class="var">w</span>)
  (<span class="special">lambda</span> (<span class="var">f</span>)
    (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
         (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) ) )</div></div></div></div>
   <span class="num">3</span> )

<span class="math"><span class="rel">≡</span></span> (<span class="func">*</span> <span class="num">3</span> (<span class="func">f</span> <span class="num">2</span>))<div class="where"><div class="wrap">
<span class="var">f</span> <span class="math"><span class="rel">≡</span></span></div> <div class="complex">(<span class="special">lambda</span> (<span class="var">x</span>)
  (((<span class="func">w</span> <span class="var">w</span>) <span class="var">meta-fact</span>) <span class="var">x</span>) )<div class="where"><div class="wrap">
<span class="var">w</span> <span class="math"><span class="rel">≡</span></span></div> <div class="complex">(<span class="special">lambda</span> (<span class="var">w</span>)
  (<span class="special">lambda</span> (<span class="var">f</span>)
    (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
         (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) ) )</div></div></div></div>

<span class="math"><span class="rel">≡</span></span> (<span class="func">*</span> <span class="num">3</span> (((<span class="func">w</span> <span class="var">w</span>) <span class="var">meta-fact</span>) <span class="num">2</span>))<div class="where"><div class="wrap">
<span class="var">w</span> <span class="math"><span class="rel">≡</span></span></div> <div class="complex">(<span class="special">lambda</span> (<span class="var">w</span>)
  (<span class="special">lambda</span> (<span class="var">f</span>)
    (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
         (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) ) )</div></div>

<span class="math"><span class="rel">≡</span></span> (<span class="func">*</span> <span class="num">3</span> (((<span class="special">lambda</span> (<span class="var">f</span>)           <span class="comment">; <em class="term">шаг II</em></span>
           (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
                (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) )<div class="where"><div class="wrap">
<span class="var">w</span> <span class="math"><span class="rel">≡</span></span></div> <div class="complex">(<span class="special">lambda</span> (<span class="var">w</span>)
  (<span class="special">lambda</span> (<span class="var">f</span>)
    (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
         (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) ) )</div></div>
         <span class="var">meta-fact</span> )
        <span class="num">2</span> ) )</pre>

<p>Остановимся на минутку, чтобы заметить, что на шаге II мы получили то же самое
выражение, что и на шаге I. Естественно, оно появится и в третий раз:</p>

<pre>(<span class="func">*</span> <span class="num">3</span> (<span class="func">*</span> <span class="num">2</span> (((<span class="special">lambda</span> (<span class="var">f</span>)
              (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
                   (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) )<div class="where"><div class="wrap">
<span class="var">w</span> <span class="math"><span class="rel">≡</span></span></div> <div class="complex">(<span class="special">lambda</span> (<span class="var">w</span>)
  (<span class="special">lambda</span> (<span class="var">f</span>)
    (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
         (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) ) )</div></div>
            <span class="var">meta-fact</span> )
           <span class="num">1</span> )))

<span class="math"><span class="rel">≡</span></span> (<span class="func">*</span> <span class="num">3</span> (<span class="func">*</span> <span class="num">2</span> ((<span class="func">meta-fact</span> (<span class="special">lambda</span> (<span class="var">x</span>)
                          (((<span class="func">w</span> <span class="var">w</span>) <span class="var">meta-fact</span>) <span class="var">x</span>) ))<div class="where"><div class="wrap">
<span class="var">w</span> <span class="math"><span class="rel">≡</span></span></div> <div class="complex">(<span class="special">lambda</span> (<span class="var">w</span>)
  (<span class="special">lambda</span> (<span class="var">f</span>)
    (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
         (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) ) )</div></div>
             <span class="num">1</span> )))

<span class="math"><span class="rel">≡</span></span> (<span class="func">*</span> <span class="num">3</span> (<span class="func">*</span> <span class="num">2</span> ((<span class="special">lambda</span> (<span class="var">n</span>)
               (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
                   (<span class="func">*</span> <span class="var">n</span> (<span class="func">f</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) )<div class="where"><div class="wrap">
<span class="var">f</span> <span class="math"><span class="rel">→</span></span> ...</div></div>
             <span class="num">1</span> )))

<span class="math"><span class="rel">≡</span></span> (<span class="func">*</span> <span class="num">3</span> (<span class="func">*</span> <span class="num">2</span> (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span> (<span class="func">*</span> <span class="var">n</span> (<span class="func">f</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))))))<div class="where"><div class="wrap">
<span class="var">n</span> <span class="math"><span class="rel">→</span></span> <span class="num">1</span>
<span class="var">f</span> <span class="math"><span class="rel">→</span></span> ...</div></div>
<span class="math"><span class="rel">≡</span></span> (<span class="func">*</span> <span class="num">3</span> (<span class="func">*</span> <span class="num">2</span> <span class="num">1</span>))

<span class="math"><span class="rel">→</span></span> <span class="num">6</span></pre>

<p>Обратите внимание, что в процессе вычислений мы действительно используем
функцию, вычисляющую факториал. Это значение выражения:</p>

<pre>(<span class="special">lambda</span> (<span class="var">x</span>)
  (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )<div class="where"><div class="wrap">
<span class="var">f</span> <span class="math"><span class="rel">≡</span></span> <span class="func" style="display: inline-block; width: 0">meta-fact</span>
<span class="var">w</span> <span class="math"><span class="rel">≡</span></span></div><div class="complex">(<span class="special">lambda</span> (<span class="var">w</span>)
  (<span class="special">lambda</span> (<span class="var">f</span>)
    (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">x</span>)
         (((<span class="func">w</span> <span class="var">w</span>) <span class="var">f</span>) <span class="var">x</span>) )) ) )</div></div></pre>

<!--\indexR{самоприменение!и рекурсия}-->
<p>Идея состоит в том, что благодаря самоприменению мы помним, как создать заново
данную функцию, и делаем это каждый раз, когда для вычислений требуется
рекурсивный вызов.</p>

<!--\indexCS{define}{как решатель уравнений}-->
<p>Таким образом можно получить простую рекурсию без использования побочных
эффектов, только с помощью <code><span class="func">fix</span></code>, комбинатора неподвижной точки. Благодаря
<span class="comb">Y</span> (или <code><span class="func">fix</span></code>), <code><span class="special">define</span></code> можно определить как решатель рекурсивных
уравнений; она принимает уравнение и связывает решение с переданным именем.
В итоге, если мы передадим <code><span class="special">define</span></code> уравнение для факториала, то с <code><span class="var">fact</span></code>
будет связано следующее значение:</p>

<pre>(<span class="func">fix</span> (<span class="special">lambda</span> (<span class="var">fact</span>)
       (<span class="special">lambda</span> (<span class="var">n</span>)
         (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
             (<span class="func">*</span> <span class="var">n</span> (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) ) ))</pre>

<p>Аналогично можно решать системы уравнений, а значит, и задавать взаимно
рекурсивные функции, собирая их уравнения воедино:</p>

<!--\indexC{odd"?}-->
<!--\indexC{even"?}-->
<pre>(<span class="special">define</span> <span class="var">odd-and-even</span>
  (<span class="func">fix</span> (<span class="special">lambda</span> (<span class="var">f</span>)
         (<span class="special">lambda</span> (<span class="var">which</span>)
           (<span class="syntax">case</span> <span class="var">which</span>
             ((<span class="var">odd</span>) (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#f</span>
                                    ((<span class="func">f</span> '<span class="var">even</span>) (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)) )))
             ((<span class="var">even</span>) (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#t</span>
                                     ((<span class="func">f</span> '<span class="var">odd</span>) (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)) ))) ) ) )) )
(<span class="special">define</span> <span class="var">odd?</span> (<span class="func">odd-and-even</span> '<span class="var">odd</span>))
(<span class="special">define</span> <span class="var">even?</span> (<span class="func">odd-and-even</span> '<span class="var">even</span>))</pre>

<p>У этого метода есть один большой недостаток: неэффективность, даже по сравнению
с наивной реализацией <code><span class="syntax">letrec</span></code>.
(И всё же, см. <span class="cite">[<a href="z1_bibliography.html#roz92">Roz92</a>, <a href="z1_bibliography.html#ser93">Ser93</a>]</span>.)
Тем не менее, он используется, особенно в качестве книжного примера. Функциональные
языки, по мнению <span class="cite">[<a href="z1_bibliography.html#pj87">PJ87</a>]</span>, тоже особо не жалуют данный метод, так как,
во-первых, он неэффективен, а во-вторых, <code><span class="func">fix</span></code> плохо сочетается с системами
вывода типов. Действительно, <code><span class="func">fix</span></code> принимает функционал<a class="footref" href="zz_footnotes.html#foot2.12"><sup>12</sup></a>, принимающий функцию типа
<span class="math"><span class="ord var">α</span><span class="rel">→</span><span class="ord var">β</span></span>, и возвращает неподвижную точку этого функционала.
То есть типом <code><span class="func">fix</span></code> является</p>

<blockquote class="equation math"><span class="open"><span class="big">(</span></span><span class="open">(</span><span class="ord var">α</span><span class="rel">→</span><span class="ord var">β</span><span class="close">)</span><span class="rel">→</span><span class="open">(</span><span class="ord var">α</span><span class="rel">→</span><span class="ord var">β</span><span class="close">)</span><span class="close"><span class="big">)</span></span><span class="rel">→</span><span class="open">(</span><span class="ord var">α</span><span class="rel">→</span><span class="ord var">β</span><span class="close">)</span></blockquote>

<!--\indexR{самоприменение!типизация}-->
<p>Но в определении <code><span class="func">fix</span></code> есть самоприменение:
<code>(<span class="func">d</span> <span class="var">d</span>)</code>.
Обозначив его тип <span class="math"><span class="ord var">γ</span></span>, имеем:</p>

<blockquote class="equation math"><span class="ord var">γ</span><span class="rel">=</span><span class="ord var">γ</span><span class="rel">→</span><span class="open">(</span><span class="ord var">α</span><span class="rel">→</span><span class="ord var">β</span><span class="close">)</span></blockquote>

<p>Потребуется или нетривиальная система типов, чтобы в ней можно было выразить
подобный рекурсивный тип, или же мы будем вынуждены реализовать
<code><span class="func">fix</span></code>
в интерпретаторе как примитивную функцию, так как её нельзя выразить средствами
самого языка.</p>


<h2 id="lisp1-2-omega/sect:conclusions"><span class="wrap"><span class="seq">2.7.</span><span class="title">Заключение</span></span></h2>

<p>В этой главе мы прошлись по наиболее заметным из вопросов, на которые сообщество
Лиспа за последние несколько десятков лет так и не смогло дать однозначного
ответа. Рассмотрев причины данных разногласий, мы поняли, что они вовсе не такие
серьёзные по своей сути. Большая часть из них связана с неоднозначностью
толкования смысла формы <code><span class="special">lambda</span></code> и различными
способами применения функций.
Хотя идея функции достаточно хорошо проработана в математике, но
в функциональных (!) языках вроде Лиспа это отнюдь не так. Различные мнения по
таким вопросам — это часть истории Лиспа. Подобно изучению истории родного
народа, их знание облегчает понимание причин тех или иных решений в дизайне
языка, а также улучшает стиль программирования в общем.</p>

<p>Также данная глава демонстрирует существенную важность понятия связывания.
В Lisp<sub>1</sub> переменная (имя) ассоциируется с уникальной привязкой (возможно
глобальной), которая в свою очередь ассоциируется с каким-либо значением. Так
как привязка уникальна, то мы говорим о значении переменной, а не о значении
привязки этой переменной. Если рассматривать привязки как абстрактный тип
данных, то можно сказать, что объекты этого типа создаются связывающими формами,
их значение определяется вычислением, изменяются они присваиванием, и могут быть
захвачены при создании замыкания, если тело замыкания ссылается на переменную,
которая ассоциирована с данной привязкой.</p>

<p>Привязки не являются полноценными объектами. Они не существуют в отрыве от
переменных и могут быть изменены только косвенно. Собственно, привязки полезны
именно потому, что они крепко-накрепко связаны со своими переменными.</p>

<!--\indexR{форма!связывающая}-->
<!--\indexR{связывающие формы}-->
<!--\indexR{область видимости!лексическая}-->
<p>Бок о бок со связывающими формами следует идея областей видимости. Область
видимости переменной — это пространство в тексте программы, где можно
обращаться к данной переменной. Область видимости переменных, создаваемых
формой <code><span class="special">lambda</span></code>, ограничена телом данной формы.
Поэтому она называется текстуальной или лексической.</p>

<p>Присваивание вносит множество неоднозначностей в идею связывания, мы изучим этот
вопрос подробнее в следующих главах.</p>


<h2 id="lisp1-2-omega/sect:exercises"><span class="wrap"><span class="seq">2.8.</span><span class="title">Упражнения</span></span></h2>

<h5 class="exercise" id="lisp1-2-omega/ex:funcall">Упражнение <span class="seq">2.1</span></h5>
<p>Следующее выражение записано на <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>. Как бы вы его перевели на Scheme?</p>

<pre>(<span class="func">funcall</span> (<span class="special">function</span> <span class="var">funcall</span>) (<span class="special">function</span> <span class="var">funcall</span>) (<span class="special">function</span> <span class="var">cons</span>) <span class="num">1</span> <span class="num">2</span>)</pre>


<h5 class="exercise" id="lisp1-2-omega/ex:lexical">Упражнение <span class="seq">2.2</span></h5>
<p>Что вернёт данная программа на псевдо-<span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> из этой главы?
О чём она вам напоминает?</p>

<pre>(<span class="special">defun</span> <span class="func">test</span> (<span class="var">p</span>)
  (<span class="special">function</span> <span class="var">bar</span>) )

(<span class="syntax">let</span> ((<span class="var">f</span> (<span class="func">test</span> <span class="hash">#f</span>)))
  (<span class="special">defun</span> <span class="func">bar</span> (<span class="var">x</span>) (<span class="func">cdr</span> <span class="var">x</span>))
  (<span class="func">funcall</span> <span class="var">f</span> '(<span class="num">1</span> . <span class="num">2</span>)) )</pre>


<h5 class="exercise" id="lisp1-2-omega/ex:innovations">Упражнение <span class="seq">2.3</span></h5>
<p>Реализуйте в вашем интерпретаторе первые две инновации из
раздела <a href="#lisp1-2-omega/sect:extensions">2.3</a>.
Речь идёт о трактовке чисел и списков как функций.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:assoc-with-comparator">Упражнение <span class="seq">2.4</span></h5>
<p>Можно научить функцию <code><span class="func">assoc/de</span></code> явно принимать компаратор (вроде <code><span class="func">eq?</span></code>,
<code><span class="func">equal?</span></code> и т. п.) через аргумент, а не задавать его внутри. Сделайте это.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:dynamic">Упражнение <span class="seq">2.5</span></h5>
<p>Используя <code><span class="func">bind/de</span></code> и <code><span class="func">assoc/de</span></code>, напишите макросы, эмулирующие
специальные формы <code><span class="special">dynamic-let</span></code>, <code><span class="special">dynamic</span></code> и <code><span class="special">dynamic-set!</span></code>.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:write-put/get-prop">Упражнение <span class="seq">2.6</span></h5>
<!--\indexC{putprop}-->
<!--\indexC{getprop}-->
<p>Напишите функции <code><span class="func">getprop</span></code> и <code><span class="func">putprop</span></code>, которые реализуют списки свойств.
Любой символ имеет личный список свойств в виде пар «ключ — значение»;
добавление в этот список осуществляет функция <code><span class="func">putprop</span></code>, поиск значения по
ключу осуществляет функция <code><span class="func">getprop</span></code>. Также, естественно, должно выполняться
утверждение</p>

<pre>(<span class="special">begin</span> (<span class="func">putprop</span> '<span class="var">symbol</span> '<span class="var">key</span> '<span class="var">value</span>)
       (<span class="func">getprop</span> '<span class="var">symbol</span> '<span class="var">key</span>) )      <span class="math"><span class="rel">→</span></span> <span class="var">value</span></pre>


<h5 class="exercise" id="lisp1-2-omega/ex:label">Упражнение <span class="seq">2.7</span></h5>
<p>Определите специальную форму <code><span class="special">label</span></code> на Lisp<sub>1</sub>.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:labels">Упражнение <span class="seq">2.8</span></h5>
<p>Определите специальную форму <code><span class="special">labels</span></code> на Lisp<sub>2</sub>.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:orderless-letrec">Упражнение <span class="seq">2.9</span></h5>
<!--\indexC{letrec}-->
<p>Придумайте, как реализовать <code><span class="syntax">letrec</span></code> с помощью <code><span class="syntax">let</span></code> и <code><span class="special">set!</span></code> так,
чтобы порядок вычисления значений-инициализаторов был неопределённым.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:fixn">Упражнение <span class="seq">2.10</span></h5>
<!--\indexR{комбинаторы!неподвижной точки!универсальный}-->
<p>У нашего комбинатора неподвижной точки на Scheme обнаружился недостаток: он
поддерживает только унарные функции. Реализуйте <code><span class="func">fix2</span></code>, работающий
с бинарными функциями. Затем <code><span class="func">fixN</span></code>, поддерживающий функции любой арности.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:nfixn">Упражнение <span class="seq">2.11</span></h5>
<p>Далее напишите функцию <code><span class="func">NfixN</span></code>, возвращающую неподвижные точки для списка
функционалов произвольной арности. Её можно использовать, например, следующим
образом:</p>

<pre>(<span class="syntax">let</span> ((<span class="var">odd-and-even</span>
       (<span class="func">NfixN</span> (<span class="func">list</span> (<span class="special">lambda</span> (<span class="var">odd?</span> <span class="var">even?</span>)    <span class="comment">; <code><span class="func">odd?</span></code></span>
                      (<span class="special">lambda</span> (<span class="var">n</span>)
                        (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#f</span> (<span class="func">even?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) )
                    (<span class="special">lambda</span> (<span class="var">odd?</span> <span class="var">even?</span>)    <span class="comment">; <code><span class="func">even?</span></code></span>
                      (<span class="special">lambda</span> (<span class="var">n</span>)
                        (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#t</span> (<span class="func">odd?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) ) )) ))
  (<span class="special">set!</span> <span class="var">odd?</span> (<span class="func">car</span> <span class="var">odd-and-even</span>))
  (<span class="special">set!</span> <span class="var">even?</span> (<span class="func">cadr</span> <span class="var">odd-and-even</span>)) )</pre>


<h5 class="exercise" id="lisp1-2-omega/ex:klop">Упражнение <span class="seq">2.12</span></h5>
<p>Рассмотрим функцию <code><span class="func">klop</span></code>.
Является ли она комбинатором неподвижной точки? Попробуйте доказать или опровергнуть, что
<code>(<span class="func">klop</span> <span class="math"><span class="ord var">f</span></span>)</code> тоже возвращает неподвижную точку <span class="math"><span class="ord var">f</span></span> подобно <code><span class="func">fix</span></code>.</p>

<!--\indexC{klop}-->
<pre>(<span class="special">define</span> <span class="var">klop</span>
  (<span class="syntax">let</span> ((<span class="var">r</span> (<span class="special">lambda</span> (<span class="var">s</span> <span class="var">c</span> <span class="var">h</span> <span class="var">e</span> <span class="var">m</span>)
             (<span class="special">lambda</span> (<span class="var">f</span>)
               (<span class="func">f</span> (<span class="special">lambda</span> (<span class="var">n</span>)
                    (((<span class="func">m</span> <span class="var">e</span> <span class="var">c</span> <span class="var">h</span> <span class="var">e</span> <span class="var">s</span>) <span class="var">f</span>) <span class="var">n</span>) )) ) )))
    (<span class="func">r</span> <span class="var">r</span> <span class="var">r</span> <span class="var">r</span> <span class="var">r</span> <span class="var">r</span>) ) )</pre>


<h5 class="exercise" id="lisp1-2-omega/ex:hyper-fact">Упражнение <span class="seq">2.13</span></h5>
<!--\indexC{fact}-->
<p>Если функция <code><span class="func">hyper-fact</span></code> определена так:</p>

<pre>(<span class="special">define</span> (<span class="func">hyper-fact</span> <span class="var">f</span>)
  (<span class="special">lambda</span> (<span class="var">n</span>)
    (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="num">1</span>
        (<span class="func">*</span> <span class="var">n</span> ((<span class="func">f</span> <span class="var">f</span>) (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) ) )</pre>

<p class="noindent">то что вернёт <code>((<span class="func">hyper-fact</span> <span class="var">hyper-fact</span>) <span class="num">5</span>)</code>?</p>


<h2 id="lisp1-2-omega/sect:recommended-reading"><span class="wrap"><span class="title">Рекомендуемая литература</span></span></h2>

<p>Кроме упомянутой ранее работы по <span class="math"><span class="ord var">λ</span></span>-исчислению <span class="cite">[<a href="z1_bibliography.html#ss78a">SS78a</a>]</span> также имеет
смысл почитать про анализ функций в <span class="cite">[<a href="z1_bibliography.html#mos70">Mos70</a>]</span> и сравнительный анализ Lisp<sub>1</sub>
и Lisp<sub>2</sub> в <span class="cite">[<a href="z1_bibliography.html#gp88">GP88</a>]</span>.</p>

<p>В <span class="cite">[<a href="z1_bibliography.html#gor88">Gor88</a>]</span> есть интересное введение в <span class="math"><span class="ord var">λ</span></span>-исчисление.</p>

<p>Комбинатор <span class="comb">Y</span> разбирается подробнее в <span class="cite">[<a href="z1_bibliography.html#gab88">Gab88</a>]</span>.</p>

</div>
</div>

</body>
</html>
