# Вычисляем формы

<a id="indexR:специальные формы"></a>
<a id="indexR:форма!специальная"></a>
<a id="indexR:Лисп!специальные формы"></a>
Каждый язык имеет некоторое количество «неприкасаемых» конструкций:
их нельзя переопределить программно, а если и можно, то не стоит.
В Лиспе такие конструкции называются _специальными формами_.
Они представляются списками, где первый элемент —
это определённый символ, принадлежащий множеству _специальных операторов_
(или синтаксических ключевых слов, как их называют в Scheme).

<a id="indexR:функции!примитивы"></a>
<a id="indexR:примитивы"></a>
<a id="indexR:диалекты Лиспа"></a>
Конкретный диалект Лиспа характеризуется набором специальных форм и библиотекой примитивных функций
(эти функции нельзя определить на самом диалекте, так как они тесно связаны с реализацией;
например, для Scheme это `call/cc`).

В некотором понимании, Лисп является лишь прикладным λ-исчислением,
расширенным набором специальных форм.
Специфика каждого конкретного диалекта Лиспа лежит только в этом наборе.
В Scheme исповедуется минимализм (`quote`, `if`, `set!`, `lambda`),
тогда как <span class="sc">Common Lisp</span> [[Ste90]](zz_bibliography.html#ste90)
определяет более тридцати специальных форм,
описывая таким образом конструкции, для которых может быть сгенерирован высокоэффективный машинный код.

Представление специальных форм делает их синтаксический анализ тривиальным:
с помощью `case`-выражения смотрим на первый элемент формы.
Если форма начинается не ключевым словом, то она означает применение функции.
В данный момент мы ограничимся лишь небольшим подмножеством специальных форм:
`quote`, `if`, `begin`, `set!` и `lambda`.
(В следующих главах мы введём другие, более специализированные формы.)

<a id="indexC:evaluate"></a>
```scheme
(define (evaluate e env)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e) (string? e) (char? e)
                 (boolean? e) (vector? e) ) e)
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (evaluate (cadr e) env)
                      (evaluate (caddr e) env)
                      (evaluate (cadddr e) env) ))
        ((begin)  (eprogn (cdr e) env))
        ((set!)   (update! (cadr e) env (evaluate (caddr e) env)))
        ((lambda) (make-function (cadr e) (cddr e) env))
        (else     (invoke (evaluate (car e) env)
                          (evlis (cdr e) env) )) ) ) )
```

<a id="indexR:синтаксис!if@\protect`if`"></a>
Для простоты, синтаксический анализ оставлен минимальным:
мы не проверяем, правильно ли записаны цитаты,
действительно ли `if` передано три аргумента[^1] и так далее.
Мы априори считаем интерпретируемые программы синтаксически корректными.

[^1]: `if` не обязательно принимает условие и ровно две альтернативы.
      К примеру, в Scheme и <span class="sc">Common Lisp</span>
      `if` может принимать как два, так и три аргумента.
      `if` в <span class="sc">EuLisp</span> и IS-Lisp исключительно тернарный.
      Le-Lisp в случае, если условие ложно, вычисляет остаток формы `if`, неявно обернув его в `begin`.

## Цитирование

<a id="indexC:quote"></a>
<a id="indexE:M-выражения"></a><a id="indexE:S-выражения"></a>
<a id="indexR:программы!как данные"></a><a id="indexR:значения!как программы"></a>
<a id="indexR:цитаты"></a>
Специальная форма `quote` позволяет записать значение, которое без цитирования было бы спутано с другим выражением.
Такой механизм необходим, если программы являются типом данных в языке —
надо же как‑то различать, где записана программа, а где данные.
Если бы для программ использовался другой синтаксис, то этой проблемы бы не было.
К примеру, изначально в Лиспе планировались M-выражения [[McC60]](zz_bibliography.html#mcc60)
для записи действий над данными, а сами данные должно были записываться S-выражениями.
Это решило бы проблему разделения кода и данных, но сделало бы невозможными макросы —
очень полезную вещь для расширения синтаксиса.
Впрочем, M-выражения долго не прожили [[McC78a]](zz_bibliography.html#mcc78a),
программы и данные стали записываться исключительно S-выражениями.
Поэтому в Лиспе есть специальная форма `quote`, служащая для разделения кода и данных.

Суть цитирования состоит в возврате выражения, следующего за ключевым словом, «как есть», без его вычисления.
Это чётко видно в следующем фрагменте кода:

```scheme
... (case (car e)
      ((quote) (cadr e)) ... ) ...
```

<a id="indexR:цитаты!явные и неявные"></a>
Интересный вопрос: а есть ли разница между явным и неявным цитированием,
например, между `33` и `'33`, или между[^7] `#(fa do sol)` и `'#(fa do sol)`?
Если первое сравнение происходит между непосредственными значениями и тут вроде бы всё очевидно,
то во втором случае сравниваются составные объекты
(хоть для Лиспа они и являются формально атомами, не списками).
Можно легко придумать несколько возможных трактовок данного выражения.
Цитирование возвращает аргумент как значение,
но сама запись `#(fa do sol)` могла бы возвращать каждый раз новый вектор из трёх символов.
Другими словами, `#(fa do sol)` может быть просто сокращённой записью выражения `(vector 'fa 'do 'sol)`,
которое, конечно же, будет означать совсем иное, нежели `'#(fa do sol)`,
и уж тем более `(vector fa do sol)`.
Мы вернёмся к этой проблеме позже, [в четвёртой главе](/ch04/05_quotation.html),
потому что, как видите, не так просто определиться, какой именно смысл придавать цитированию.

[^7]: Напомним: в Scheme запись `#(...)` означает процитированный вектор.

## Ветвление

<a id="indexC:if"></a>
Вспомним, как работает условный оператор `if`:
эта форма вычисляет свой первый аргумент (_условие_),
затем в зависимости от результата вычислений выбирает,
возвращать значение второго аргумента (_следствия_) или третьего (_альтернативы_).
Эта идея выражается следующим кодом:

```scheme
... (case (car e)
      ((if) (if (evaluate (cadr e) env)
                (evaluate (caddr e) env)
                (evaluate (cadddr e) env) )) ... ) ...
```

<a id="indexR:представление!логических значений"></a>
<a id="indexR:логические значения"></a>
Эта программа не совсем точно учитывает представление логических значений.
Очевидно, что здесь смешиваются два языка:
Scheme (или хотя бы что‑то неотличимо похожее на него) и Scheme (или что‑то довольно похожее).
Причём мы определяем второй в терминах первого.
Поэтому между ними присутствуют примерно те же отношения, что и между Паскалем,
на котором написана первая реализация T<span style="text-transform: uppercase; vertical-align: -0.5ex; margin-left: -0.1334em; margin-right: -0.075em; line-height: 1ex;">e</span>X, и самой системой T<span style="text-transform: uppercase; vertical-align: -0.5ex; margin-left: -0.1334em; margin-right: -0.075em; line-height: 1ex;">e</span>X [[Knu84]](zz_bibliography.html#knu84).
Соответственно, нет ни единого повода считать способы представления логических значений в этих языках одинаковыми.

Функция `evaluate` возвращает значения определяемого языка.
Они априори никак не связаны с логическими значениями языка, используемого для реализации.
Следуя соглашению о том, что любой объект, кроме логической _лжи_, должен считаться логической _истиной_, мы запишем:

```scheme
... (case (car e)
      ((if) (if (not (eq? (evaluate (cadr e) env) the-false-value))
                (evaluate (caddr e) env)
                (evaluate (cadddr e) env) )) ... ) ...
```

<a id="indexC:the-false-value"></a>
Здесь ожидается, что переменная `the-false-value` хранит значение _лжи_ определяемого языка, выраженное в терминах определяющего.
Вариантов выбора такого представления много. Например, так:

```scheme
(define the-false-value (cons "false" "boolean"))
```

Функция `eq?` в Scheme сравнивает не значения, а адреса объектов,
поэтому любое другое значение определяемого языка никак нельзя будет спутать со значением переменной `the-false-value`.

<a id="indexC:()"></a>
<a id="indexC:NIL"></a>
<a id="indexR:пустой список, ()"></a>
Вопрос представления логических значений вовсе не тривиален.
В истории Лиспа полно споров на тему различий между булевым значением _ложь_, пустым списком `()` и символом `NIL`.
Наиболее чёткая позиция по этому вопросу:
_ложь_ это не `()` (в конце концов, это всего лишь пустой список),
и они оба тем более не имеют никакого отношения к символу, составленному из букв `N`, `I`, `L`.

Такую позицию занимает и Scheme; об этом всё же смогли договориться за пару
недель до принятия стандарта IEEE [[IEE91]](zz_bibliography.html#iee91).

Так что в Scheme теперь всё хорошо (разве что `()` по-английски всё ещё читается как *nil*!).
В изначальном Лиспе _ложь_, `()` и `NIL` — синтаксически одно и то же.
В Le-Lisp `NIL` это переменная со значением `()`,
а пустой список (вместе с пустым символом `||`) используется в качестве логической _лжи_.

## Последовательность

<a id="indexC:begin"></a>
<a id="indexC:progn"></a>
Существует специальная форма, позволяющая вычислить группу форм последовательно и в определённом порядке.
Как и старые добрые блоки `begin ... end` из семейства языков Алгола, в Scheme эта форма называется `begin`.
В других Лиспах она обычно зовётся `progn` — обобщенная версия `prog1`, `prog2`...
Организацию последовательности мы перепоручаем функции `eprogn`.

<a id="indexC:eprogn"></a>
```scheme
... (case (car e)
      ((begin) (eprogn (cdr e) env)) ... ) ...

(define (eprogn exps env)
  (if (pair? exps)
      (if (pair? (cdr exps))
          (begin (evaluate (car exps) env)
                 (eprogn (cdr exps) env) )
          (evaluate (car exps) env) )
      '() ) )
```

Это каноничное определение последовательных вычислений.
Обратите внимание на хвостовую рекурсию:
последний вызов `evaluate` выполняется так, как если бы вся последовательность состояла из одного-единственного элемента.
(О хвостовой рекурсии мы поговорим подробнее [в третьей главе](ch03/06_continuations.html#Хвостовая-рекурсия).)

<a id="indexC:begin!возвращаемое значение"></a>
<a id="indexR:возвращаемые значения!формы (begin)@формы \protect`(begin)`"></a>
<a id="indexC:empty-begin"></a>
Ещё одним интересным моментом является значение формы `(begin)`.
Сейчас это пустой список.
Но почему именно `()`, почему не что‑то другое, вроде `:3` или `(^_^)`?
Мы выбрали пустой список по привычке, доставшейся в наследство от Лиспа:
в любой непонятной ситуации возвращай `NIL`.
Но в мире, где _ложь_, `NIL` и `()` — это совершенно различные вещи, что из них лучше подходит на роль *ничего*?
Поэтому пусть в нашем языке вычисление `(begin)` будет возвращать специальное значение `empty-begin`,
которое определяется как (почти) случайное число `813` [[Leb05]](zz_bibliography.html#leb05).

<a id="indexC:eprogn"></a><a id="indexC:empty-begin"></a>
```scheme
(define (eprogn exps env)
  (if (pair? exps)
      (if (pair? (cdr exps))
          (begin (evaluate (car exps) env)
                 (eprogn (cdr exps) env) )
          (evaluate (car exps) env) )
      empty-begin ) )

(define empty-begin 813)
```

<a id="indexR:синтаксис!begin@`(begin)`"></a>
<a id="indexC:unspecified"></a>
Корень нашей проблемы в том, что `begin` *обязана* вернуть какое‑то значение.
Как и Scheme, определяемый язык может не придавать какого-либо смысла форме `(begin)`.
Это утверждение можно трактовать по-разному:
мы можем или допускать такое написание и возвращать любое удобное значение на выбор реализации,
или же не допускать и считать ошибкой.
Программистам вовсе не стоит использовать `begin` без аргументов,
так как не определено, что именно получится в результате.
Некоторые реализации имеют специальный объект:
`#<unspecified>`, который возвращается в случае, когда нет ничего более подходящего.
Обычно единственное, что с ним можно сделать — это вывести на
печать.
(Не следует путать этот объект с псевдозначением у [неопределённых переменных](ch02/06_recursion.html#Объявление-неинициализированных-привязок).)

<a id="indexR:язык!чисто функциональный"></a>
<a id="indexR:побочные эффекты"></a>
В чисто функциональных языках последовательное вычисление выражений бесполезно.
Действительно, если у выражений нет побочных эффектов, то какой в таком случае смысл что‑то вычислять и не использовать возвращаемые значения?
Однако, иногда в этом может быть смысл.
Представим себе игру, написанную на чисто функциональном языке.
Очевидно, что вычисления занимают какое‑то время вне зависимости от того, используются ли их результаты или нет;
и нас может интересовать именно этот «побочный эффект» — замедление работы, — а не получаемые результаты.
Тогда можно последовательно что‑то вычислять, например, чтобы скорость игры была адекватна рефлексам игрока
(если только компилятор не посчитает себя самым умным и не удалит «бесполезный» код).

<a id="indexC:begin!необходимость"></a>
Так как в Scheme есть операции ввода-вывода, которые имеют побочные эффекты,
то для нас форма `begin` может оказаться полезной.
Ведь как очевидно, что лучше сначала задать вопрос (с помощью `display`),
а потом прочитать ответ (с помощью `read`), чем сделать наоборот.
Здесь‑то как раз и нужно упорядочить вычисления.
Но не только `begin` может их упорядочивать.
Например, условный оператор может:

```scheme
(if α β β) ≡ (begin α β)
```

<a id="basics/forms/sequence/par:gensym-puzzle"></a>
И `lambda` тоже может:[^5]

```scheme
(begin α β) ≡ ((lambda (void) β) α)
```

Как видно из этого примера, в Scheme `begin` не является необходимой специальной формой,
так как её поведение можно проэмулировать с помощью функций благодаря тому,
что при вызове функции её аргументы всегда вычисляются перед исполнением тела
(передача аргументов _по значению_).

[^5]: Переменная `void` не должна быть свободной в `β`.
      Это условие выполняется, если `void` никогда не встречается в `β`.
      Обычно в таком случае используется `gensym`, чтобы получить гарантированно уникальное имя переменной.
      (Однако, см. [упражнение 1.11](ch01/zz_exercises.html#basics/ex:no-gensym).)

## Присваивание

<a id="indexC:set!"></a>
<a id="indexR:присваивание"></a>
<a id="indexR:соглашения именования!побочных эффектов"></a>
Как и во многих других языках, в нашем диалекте Лиспа значения переменных можно менять.
Изменение значения переменной называется _присваиванием_.
Значение переменной надо изменять в её окружении, мы поручаем эту задачу функции `update!`[^6].

```scheme
...
(case (car e)
      ((set!) (update! (cadr e) env
                       (evaluate (caddr e) env))) ...
) ...
```

Присваивание выполняется в два шага: сначала вычисляется новое значение, потом новое значение заменяет старое.
Стоит заметить, что обновлённая переменная не является значением данной формы.
Мы ещё вернёмся к вопросу о возвращаемом значении операции присваивания [в четвёртой главе](/ch04/00_assignment_and_side_effects.html).
Пока только запомните, что стандартом оно не определено.

[^6]: В соответствии с принятым в Scheme соглашением, имена функций с побочными эффектами оканчиваются на восклицательный знак.

## Абстракция

<a id="indexR:абстракция"></a>
Функции (также называемые _процедурами_ в Scheme) являются результатом вычисления специальной формы `lambda`,
чьё имя ссылается на понятие _абстракции_ в λ-исчислении.
Работу по созданию функции мы поручаем функции `make-function`,
которой передаём всё необходимое: список аргументов, тело функции и текущее окружение.

```scheme
... (case (car e)
      ((lambda) (make-function (cadr e) (cddr e) env)) ... ) ...
```

## Аппликация

<a id="indexR:аппликация"></a>
<a id="indexR:комбинация"></a>
<a id="indexR:терм!функциональный"></a>
<a id="indexR:функциональный терм"></a>
Если первый элемент формы не является специальным оператором, то она означает вызов функции,
которое в λ-исчислении называется _аппликацией_ или _комбинацией_.
Функция, полученная в результате вычисления первого элемента, применяется к аргументам, которые мы получим, вычислив остальные элементы.
Эти действия описываются следующим кодом:

```scheme
... (case (car e)
      (else (invoke (evaluate (car e) env)
                    (evlis (cdr e) env) )) ) ...
```

Вспомогательная функция `evlis` принимает список выражений и возвращает список соответствующих им значений.
Она определяется следующим образом:

<a id="indexC:evlis"></a>
```scheme
(define (evlis exps env)
  (if (pair? exps)
      (cons (evaluate (car exps) env)
            (evlis (cdr exps) env) )
      '() ) )
```

Функция `invoke` применяет свой первый аргумент (функцию) ко второму (списку её аргументов) и возвращает результат вычислений.
В общем, `invoke` похожа на привычную `apply`, разве что требует явного указания окружения.
(Далее [в разделе 1.6](/ch01/06_functions.html) мы рассмотрим подробнее непростые взаимоотношения функций и окружений.)

### Ещё немного об `evaluate`

<a id="indexR:порядок вычислений!термов аппликации"></a>
Рассмотренное описание языка является более-менее полным.
Мы не разобрали лишь несколько вспомогательных функций:
`lookup` и `update!`, отвечающие за окружения,
и `make-function` вместе с `invoke`, занимающиеся функциями.
Но даже сейчас нам уже многое известно об `evaluate`.
Например, наш диалект имеет единое пространство имён,
функции в нём являются полноценными объектами языка,
причём обладают равными правами с другими объектами (как в [Lisp<sub>1</sub>](ch02/00_lisp_1_2_omega.html)).
Однако, мы до сих пор не знаем порядок вычисления аргументов функций.

В нашем случае он зависит от порядка вычисления аргументов у `cons`, которая используется в `evlis`.
При желании мы легко можем указать любой определённый порядок, скажем, слева направо:

```scheme
(define (evlis exps env)
  (if (pair? exps)
      (let ((argument1 (evaluate (car exps) env)))
        (cons argument1 (evlis (cdr exps) env)) )
      '() ) )
```

Вот так без введения специальных конструкций[^9] мы уточнили поведение определяемого языка.
Именно этому посвящена первая части книги:
всё более точному описанию языка с помощью всё более ограниченных возможностей.

[^9]: Как известно, `let` — это всего лишь простой макрос:
      `(let ((x p1)) p2) ≡ ((lambda (x) p2) p1)`.
