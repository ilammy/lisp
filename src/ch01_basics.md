<a id="basics/sect:representing-functions"></a>
## Представление функций

Наверное, проще всего представлять функции с помощью функций.
Естественно, это
не тавтология, и читать следует так: «функции определяемого языка проще всего
представлять функциями языка определения».
Это сильно упрощает механизм вызова:
функция `invoke` должна лишь проверить, действительно ли её первый аргумент
является функцией: чем‑то, что можно вызвать.

<a id="indexC:invoke"></a>
```scheme
(define (invoke fn args)
  (if (procedure? fn) (fn args)
      (wrong "Not a function" fn) ) )
```

Проще некуда.
Даже может возникнуть вопрос, зачем вообще нужна отдельная
функция, когда весь этот код можно было встроить сразу в `evaluate`.
Причина,
по которой так сделано, в том, что мы показываем структуру будущих
интерпретаторов, а в них `invoke` будет уже не такой простой.
Кстати,
попробуйте сейчас выполнить упражнения \ref{basics/ex:def-call/cc}
и \ref{basics/ex:def-apply}.

<a id="indexR:аппликация!порядок вычисления термов"></a>
<a id="indexR:порядок вычислений!термов аппликации"></a>
Также у нас появляется новый тип ошибок, возникающих при попытке вызвать
невызываемое.
Сейчас мы обрабатываем такие ошибки в момент применения функции
к уже вычисленным аргументам, но мы могли бы предупреждать пользователя раньше.
В таком случае нам необходимо задать порядок вычисления элементов формы вызова
функции:

\begin{enumerate}
  \item вычислить элемент на месте функции;

  \item если это не функция, сообщить об ошибке;

  \item вычислить аргументы слева направо;

  \item сравнить количество аргументов с арностью функции
        и, если они не совпадают, то сообщить об ошибке.
\end{enumerate}

Вычислять аргументы слева направо кажется логичным для людей, читающих слева
направо.
Это и запрограммировать легче, в итоге порядок прост и понятен.
Сложности возникают только у компилятора, потому что если ему захочется поменять
этот порядок (например, чтобы эффективнее использовать регистры процессора), то
он будет вынужден доказать, что это не изменит смысла программы.

Конечно, мы могли бы действовать эффективнее, проверяя арность ещё раньше:

\begin{enumerate}
  \item вычислить элемент на месте функции;

  \item если это не функция, сообщить об ошибке, иначе запомнить ожидаемое
        количество аргументов;

  \item вычислять аргументы слева направо до тех пор, пока их количество
        согласуется с арностью функции, в случае проблем сообщить об ошибке;

  \item применить функцию к аргументам.\footnote*{Функция могла бы потом
        ещё проверять на правильность типы переданных аргументов, но это
        не имеет отношения к механизму вызова.}
\end{enumerate}

Стандарт {\CommonLisp} требует, чтобы аргументы вычислялись строго слева
направо, но с целью оптимизации позволяет вычислять функциональный элемент
списка до или после остальных.

Scheme же не накладывает условий на порядок вычисления всех элементов формы
вызова функции, включая сам элемент-функцию.
Так как ограничений нет, то
компилятор волен выбирать любой устраивающий его порядок.
\seePage[denotational/sect:eval-order] А пользователь, в свою очередь, не может
рассчитывать на какой-либо определённый порядок вычислений и должен использовать
`begin`, чтобы задать необходимый порядок явно.

Считается плохим стилем использовать вызовы функций, чтобы получить побочные
эффекты в нужной последовательности.
Поэтому следует избегать выражений вроде
`(f (set! f $\pi$) (set! f $\pi'$))`, где неясно, какая же функция будет
вызвана на самом деле.
Ошибки, возникающие в подобных случаях, очень сложно
отлавливать.


\subsection*{Окружение исполнения функций}

<a id="indexR:окружение!исполнения тела функции"></a>
Применение функции сводится к вычислению выражений, составляющих её тело,
в окружении, где аргументы функции связаны со значениями, переданными при вызове
функции.
Вспомните, что при вызове `make-function` мы передали всё
необходимое для этого, находящееся в распоряжении `evaluate`.
В оставшейся
части этого раздела мы будем разбирать используемые при вычислениях окружения,
в программах они будут набраны *курсивом*.


\subsubsection{Минимальное окружение}

Для начала рассмотрим минимально возможное окружение:

<a id="indexC:make-function"></a>
```scheme
(define (make-function variables body env)
  (lambda (values)
    (eprogn body (extend |*env.init*| variables values)) ) )
```

\indexE{K@\protect\comb{K}, комбинатор}
\indexR{комбинаторы!K@\protect\comb{K}}
В строгом соответствии с ранее описанным соглашением, тело функции вычисляется
в окружении, где аргументы функции связаны с переданными значениями.
Например,
получив в результате вызова `make-function` комбинатор \comb{K}, определяемый
как `(lambda (a b) a)`, мы можем его вызвать следующим образом:

```scheme
(K 1 2) |\is| 1
```

Но есть и неприятность: функция может использовать только свои аргументы и
локальные переменные, потому что мы определили *env.init* как пустое
окружение.
В нём нет даже базовых функций из глобального окружения вроде
`car` или `cons`.


\subsubsection{Улучшенное окружение}

Хорошо, попробуем улучшить наше определение следующим образом:

```scheme
(define (make-function variables body env)
  (lambda (values)
    (eprogn body (extend |*env.global*| variables values)) ) )
```

Замечательно, теперь наши функции имеют доступ к глобальному окружению и всем
его функциям.
А что если мы попробуем определить взаимно рекурсивные функции?
Также, какой результат даст программа слева (справа она же с раскрытыми
макросами)?

{\def\E{\hbox to 0pt{\kern0.3em$\equals$}}
```scheme
(let ((a 1))            ((lambda (a)
  (let ((b (+ 2 a)))       ((lambda (b)
    (list a b) ) )   |\E|         (list a b) )
                            (+ 2 a) ) )
                         1 )
```}

Давайте рассмотрим по шагам, как вычисляется это выражение:

```scheme
((lambda (a) ((lambda (b) (list a b)) (+ 2 a))) 1)|\begin{where}
                                                   \- *env.global*
                                                   \end{where}|
|\equals| ((lambda (b) (list a b)) (+ 2 a))|\begin{where}
                                            \- a {\is} 1
                                            \- *env.global*
                                            \end{where}|
|\equals| (list a b)|\begin{where}
                     \- b {\is} 3
                     \- *env.global*
                     \end{where}|
```

Тело внутренней функции `(lambda (b) (list a b))` выполняется в окружении,
полученном расширением глобального окружения переменной `b`.
Всё верно.
Но
в этом окружении нет необходимой переменной `a`!


\subsubsection{Улучшенное окружение (вторая попытка)}

Так как нам надо видеть переменную `a` во внутренней функции, то достаточно
будет передать `invoke` текущее окружение, а она в свою очередь передаст его
вызываемой функции.
Чтобы реализовать эту идею, надо немного подправить
`evaluate` и `invoke`; чтобы не путать эти определения с предыдущими,
пусть они начинаются на `d.`:

<a id="indexC:d.evaluate"></a>
<a id="indexC:d.invoke"></a>
<a id="indexC:d.make-function"></a>
```scheme
(define (d.evaluate e env)
  (if (atom? e) ...
      (case (car e)
        ...
        ((lambda) (d.make-function (cadr e) (cddr e) env))
        (else     (d.invoke (d.evaluate (car e) env)
                            (evlis (cdr e) env)
                            env )) ) ) )

(define (d.invoke fn args env)
  (if (procedure? fn)
      (fn args env)
      (wrong "Not a function" fn) ) )

(define (d.make-function variables body |*def.env*|)
  (lambda (values |*current.env*|)
    (eprogn body (extend |*current.env*| variables values)) ) )
```

В этом определении стоит заметить, что передача окружения определения `env`
через переменную *def.env* бессмысленна, так как при вызове используется лишь
текущее окружение *current.env*.

<a id="indexR:стек!вызовов"></a>
Давайте теперь ещё раз рассмотрим пример, приведённый выше.
Сейчас переменные
не пропадают:

```scheme
((lambda (a) ((lambda (b) (list a b)) (+ 2 a))) 1)|\begin{where}
                                                   \- *env.global*
                                                   \end{where}|
|\equals| ((lambda (b) (list a b)) (+ 2 a))|\begin{where}
                                            \- a {\is} 1
                                            \- *env.global*
                                            \end{where}|
|\equals| (list a b)|\begin{where}
                     \- b {\is} 3
                     \- a {\is} 1
                     \- *env.global*
                     \end{where}|
```

Заодно мы явно видим *стек вызовов*: каждая связывающая форма сначала
укладывает свои новые переменные поверх текущего окружения, а потом убирает их
оттуда после окончания вычислений.


\subsubsection{Исправляем проблему}

Но даже при таком определении всё ещё есть проблемы.
Рассмотрим следующий
пример:

```scheme
(((lambda (a)
     (lambda (b) (list a b)) )
  1 )
 2 )
```

Функция `(lambda (b) (list a b))` создаётся в окружении, где `a` связана
со значением `1`, но в момент вызова в окружении будет присутствовать
только `b`.
Таким образом, мы опять потеряли переменную `a`.

Без сомнения, вы заметили, что в определении `d.make-function` присутствуют
два окружения: окружение определения *def.env* и окружение исполнения
*current.env*.
В жизни функции есть два важных события: её создание и
её вызов(ы).
Очевидно, что создаётся функция только однажды, а вызываться может
несколько раз; или вообще никогда не вызываться.
Следовательно,
единственное\footnote{На самом деле, здесь можно использовать любое необходимое
окружение.
См. про форму `closure` на
странице [assignement/assignement/para:closure](xxx_appropriate.html#assignement/assignement/para:closure).} окружение, которое мы
однозначно можем связать с функцией, — это окружение, в котором она была
создана.
Вернёмся к исходным определениям функций `evaluate` и `invoke`,
но в этот раз функцию `make-function` запишем следующим образом:

<a id="indexC:make-function"></a>
```scheme[label=basics/representing-functions/fixing/src:inject-current-env]
(define (make-function variables body |*env*|)
  (lambda (values)
    (eprogn body (extend |*env*| variables values)) ) )
```

Теперь все приведённые примеры работают нормально.
В частности, пример выше
вычисляется следующим образом:

```scheme
(((lambda (a) (lambda (b) (list a b))) 1) 2)|\begin{where}
                                             \- *env.global*
                                             \end{where}|
|\equals| ((lambda (b) (list a b))|\begin{where}
                                   \- a {\is} 1
                                   \- *env.global*
                                   \end{where}|
    2 )|\begin{where}
        \- *env.global*
        \end{where}|
|\equals| (list a b)|\begin{where}
                     \- b {\is} 2
                     \- a {\is} 1
                     \- *env.global*
                     \end{where}|
```

<a id="indexR:абстракция!замыкание"></a>
<a id="indexR:абстракция!значение"></a>
<a id="indexR:возвращаемые значения!абстракций"></a>
<a id="indexR:замыкания (closures)"></a>
Форма `(lambda (b) (list a b))` создаётся в глобальном окружении, расширенном
переменной `a`.
Когда эта функция вызывается, она расширяет окружение своего
создания переменной `b`, таким образом, тело функции будет вычисляться
в окружении, где обе переменные `a` и `b` присутствуют.
После того, как
функция вернёт результат, исполнение продолжается в глобальном окружении.
Мы
будем называть значение абстракции _замыканием_ (closure), потому что при
создании этого значения тело функции становится замкнутым в окружении своего
определения.

Стоит отметить, что сейчас `make-function` сама использует замыкания языка
определения.
Это не является обязательным, как мы покажем далее в третьей главе.
\seePage[escape/actors/ssect:functions] Функция `make-function` возвращает
замыкания, а это — характерная черта функциональных языков программирования.


\subsection{Динамическая и лексическая области видимости}<!--  -->
\label{basics/representing-functions/ssect:dynamic-and-lexical-binding}

Из этого разговора об окружениях можно сделать два вывода.
Во-первых, ясно,
что с окружениями не всё так просто.
Любое вычисление всегда производится
в каком‑то окружении, следовательно, необходимо эффективно реализовывать их
использование.
В третьей главе рассматриваются более сложные вещи вроде
раскрутки стека и соответствующей формы `unwind-protect`, которые потребуют
от нас ещё более точного контроля над окружениями.

<a id="indexR:лексическое связывание"></a><a id="indexR:динамическое связывание"></a>
<a id="indexR:связывание!лексическое"></a><a id="indexR:связывание!динамическое"></a>
<a id="indexR:Лисп!лексический"></a><a id="indexR:Лисп!динамический"></a>
Второй момент связан с двумя рассмотренными в предыдущем разделе вариантами,
которые являются примерами _лексического_ и \term{динамического
связывания}\footnote{В объектно-ориентированных языках под динамическим
связыванием обычно понимается механизм выбора метода объекта на основе его
реального типа во время исполнения программы, в противоположность статическому
связыванию, при котором метод выбирается компилятором исходя из типа переменной,
которая хранит рассматриваемый объект.} (также применяются термины лексическая и
динамическая область видимости).
В *лексическом* Лиспе функция выполняется
в окружении своего определения, расширенном собственными переменными, тогда как
в *динамическом* — расширяет текущее окружение, окружение своего вызова.

Сейчас в моде лексическое связывание, но это не значит, что у динамического нет
будущего.
С одной стороны, именно динамическое связывание применяется
в некоторых довольно популярных языках вроде \TeX [[knu84]](zz_bibliography.html#knu84),
Emacs Lisp\trnote{Начиная с Emacs Lisp v.\,24 и Perl 5, эти языки имеют и
лексические переменные.} [[llst93]](zz_bibliography.html#llst93), Perl [[ws91]](zz_bibliography.html#ws91).

С другой стороны, сама идея динамической области видимости является важной
концепцией программирования.
Она соответствует установке связей перед
выполнением вычислений и гарантированному автоматическому удалению этих связей
после завершения вычислений.

<a id="indexR:исключения"></a>
<a id="indexR:поиск с возвратом"></a>
Такую стратегию можно эффективно применять, например, в искусственном
интеллекте.
В этом случае сначала выдвигается некая гипотеза, затем из неё
вырабатываются следствия.
Как только система натыкается на противоречие, то
гипотезу следует отвергнуть и перейти к следующей.
Это называется \term{поиском
с возвратом}.
Если следствия гипотез хранятся без использования побочных
эффектов, например, в А-списках, то отвержение гипотезы автоматически и без
проблем утилизирует и все её следствия.
Но если для этого используются
глобальные переменные, массивы {\itd}, то тогда за ненужной гипотезой
приходится долго убирать, вспоминая, каким же было состояние памяти в момент
формулировки гипотезы и какие его части можно откатить до старых значений, чтобы
ничего не сломать! Динамическая область видимости позволяет гарантировать
существование переменной с определённым значением на время и только во время
вычислений, независимо от того, будут они успешны или нет.
Это свойство также
широко используется при обработке исключений.

<a id="indexR:область видимости"></a>
_Область видимости_ переменной — это, можно сказать, географическое
понятие в программе: местность, где переменная встречается и её можно
использовать.
В чистом Scheme (не обременённом полезными, но не абсолютно
необходимыми вещами вроде `let`) есть только одна связывающая форма:
`lambda`.
Это единственная форма, вводящая новые переменные и предоставляющая
им область видимости в рамках определяемой функции.
В динамическом же Лиспе
область видимости в принципе не может быть ограничена функцией.
Рассмотрим
следующий пример:

```scheme
(define (foo x) (list x y))
(define (bar y) (foo 1991))
```

В лексическом Лиспе переменная `y` в `foo`\footnote{О происхождении
*foo* см. [[ray91]](zz_bibliography.html#ray91).} — это всегда ссылка на глобальную
переменную `y`, которая не имеет никакого отношения к `y` внутри `bar`.
В динамическом же Лиспе переменная `y` из `bar` будет видима в `foo`
внутри `bar`, потому что в момент вызова `foo` переменная `y` уже
находилась в текущем окружении.
Следовательно, если мы дадим глобальной `y`
значение `0`, то получим следующие результаты:

```scheme
(define y 0)
(list (bar 100) (foo 3)) |\is| ((1991 0) (3 0))   ; в лексическом Лиспе
(list (bar 100) (foo 3)) |\is| ((1991 100) (3 0)) ; в динамическом Лиспе
```

<a id="indexR:свободные переменные!и области видимости"></a>
Заметьте, что в динамическом Лиспе `bar` понятия не имеет о том, что
в `foo` используется её же локальная переменная `y`, а `foo` не знает
о том, в каком именно окружении следует искать значение своей свободной
переменной `y`.
Просто `bar` при вызове положила в текущее окружение
переменную `y`, а внутренняя функция `foo` нашла её в своём
текущем окружении.
Непосредственно перед выходом `bar` уберёт свою `y` из
окружения, и глобальная переменная `y` снова станет видна.

Конечно, если не использовать свободные переменные, то нет особой разницы между
динамической и лексической областями видимости.

Лексическое связывание получило своё имя потому, что в данном случае достаточно
иметь только код функции, чтобы с уверенностью отнести каждую используемую в ней
переменную к одному из двух классов: или переменная находится внутри связывающей
формы и является локальной, или же это глобальная переменная.
Это чрезвычайно
просто: достаточно взять исходный код, взять карандаш (или мышку) и поставить
его кончик на переменную, значение которой нас интересует, после чего следует
вести карандаш справа налево, снизу вверх до тех пор, пока не встретим первую
связывающую форму.
Динамическое же связывание названо в честь концепции
_динамического времени жизни_ переменных, которую мы будем рассматривать
позже.
\seePage[escape/forms/ssect:dynamic]

Scheme поддерживает только лексические переменные.
{\CommonLisp} поддерживает
оба типа с одинаковым синтаксисом.
Синтаксис {\EuLisp} и {\ISLisp} разделяет эти
два типа переменных, и они находятся в отдельных пространствах имён.
\seePage[lisp1-2-omega/sect:namespaces]

<a id="indexR:область видимости!конфликт имён"></a>
<a id="indexR:переменные!сокрытие имён"></a>
<a id="indexR:сокрытие переменных"></a>
\indexR{сокрытие переменных|seealso{области видимости}}
Область видимости переменной может прерываться.
Такое случается, когда одна
переменная _скрывает_ другую из‑за того, что обе имеют одинаковое имя.
Лексические области видимости вкладываются друг в друга, скрывая переменные
с совпадающими именами из внешних областей.
Этот известный «блокирующий»
порядок разрешения конфликтов унаследован от Алгола 60.

Под влиянием $\lambda$-исчисления, в честь которого названа специальная
форма `lambda` [[per79]](zz_bibliography.html#per79), \LISP 1.0 был сделан динамическим, но вскоре
Джон Маккарти осознал, что он ожидал получить от следующего выражения
`(2 3)`, а не `(1 3)`:

```scheme
(let ((a 1))
  ((let ((a 2)) (lambda (b) (list a b)))
   3 ) )
```

<a id="indexC:function!для замыканий"></a>
<a id="indexC:lambda!как ключевое слово"></a>
Эта аномалия (не осмелюсь назвать её ошибкой) была исправлена введением новой
специальной формы `function`.
Она принимала `lambda`-форму и создавала
_замыкание_ — функцию, связанную с окружением, в котором она определена.
При вызове замыкания вместо текущего окружения расширялось окружение
определения, замкнутое внутри него.
Вместе с изменениями `d.evaluate` и
`d.invoke`, форма `function`\footnote{Наша имитация не совсем точна, так
как существует немало диалектов Лиспа (вроде CLtL1 [[ste84]](zz_bibliography.html#ste84)), где
`lambda` — это не специальный оператор, а только ключевое слово-маркер
вроде `else` внутри `cond` и `case`.
В этом случае `d.evaluate`
может вообще не знать ни о какой `lambda`.
Иногда даже накладываются
ограничения на положение `lambda`-форм, разрешающие им находиться только
внутри `function` и в определениях функций.} выражается так:

<a id="indexC:d.invoke"></a><a id="indexC:d.make-function"></a><a id="indexC:d.make-closure"></a>
```scheme[label=basics/repr-func/dyn-and-lex-bind/src:closure-eval]
(define (d.evaluate e env)
  (if (atom? e) ...
      (case (car e)
        ...
        ((function)   ; Синтаксис: `(function (lambda *аргументы* *тело*))`
         (let* ((f   (cadr e))
                (fun (d.make-function (cadr f) (cddr f) env)) )
           (d.make-closure fun env) ) )
        ((lambda) (d.make-function (cadr e) (cddr e) env))
        (else     (d.invoke (d.evaluate (car e) env)
                            (evlis (cdr e) env)
                            env )) ) ) )

(define (d.invoke fn args env)
  (if (procedure? fn)
      (fn args env)
      (wrong "Not a function" fn) ) )

(define (d.make-function variables body env)
  (lambda (values current.env)
    (eprogn body (extend current.env variables values)) ) )

(define (d.make-closure fun env)
  (lambda (values current.env)
    (fun values env) ) )
```

<a id="indexR:переменные!специальные"></a>
<a id="indexC:special"></a>
Но это ещё не конец всей истории.
`function` — это лишь костыль, на
который опиралась хромая реализация Лиспа.
С созданием первых компиляторов стало
ясно, что с точки зрения производительности у лексической области видимости есть
(ожидаемое при компиляции) преимущество: можно сгенерировать код для более-менее
прямого доступа к любой переменной, а не динамически отыскивать её значение
заново каждый раз.
Тогда по умолчанию стали делать все переменные лексическими,
за исключением тех, которые были явно помечены как динамические или, как тогда
их называли, _специальные_.
Выражение `(declare (special *x*))`
являлось командой компиляторам \LISP 1.5, \CommonLisp, Maclisp и других,
говорившей, что переменная *x* ведёт себя «особенно».

<a id="indexR:ссылочная прозрачность"></a>
Эффективность была не единственной причиной принятия такого решения.
Другой
причиной была потеря _ссылочной прозрачности_ (\english{referential
transparency}).
Ссылочная прозрачность — это свойство языка, заключающееся
в том, что замена в программе любого выражения его эквивалентом никак не изменит
поведение этой программы (оба варианта программы или вернут одно и то же
значение, или вместе застрянут в бесконечном цикле).
Например:

```scheme
(let ((x (lambda () 1))) (x)) |\eq| ((let ((x (lambda () 1))) x)) |\eq| 1
```

В общем случае ссылочная прозрачность теряется, если язык позволяет побочные
эффекты.
Чтобы она сохранилась и при наличии побочных эффектов, необходимо
точнее определить понятие эквивалентных выражений.
Scheme обладает ссылочной
прозрачностью, если не использовать присваивания, функции с побочными эффектами
и продолжения.
\seeEx[escape/ex:crazy-cc] Это свойство желаемо и в наших
программах, если мы хотим сделать их по-настоящему повторно используемыми, как
можно менее зависимыми от контекста использования.

<a id="indexR:переменные!безымянные"></a>
<a id="indexR:альфа@$\alpha$-конверсия"></a>
Локальные переменные функций вроде `(lambda (u) (+ u u))` иногда называются
*безымянными*.
Их имена ничего не значат и могут быть абсолютно
произвольными.
Функция `(lambda (n347) (+ n347 n347))` — это та же
самая\footnote{В терминах $\lambda$-исчисления подобная замена имён называется
$\alpha$-конверсией.} функция, что и `(lambda (u) (+ u u))`.

Мы ожидаем, что в языке будет сохраняться этот инвариант.
Но это невозможно
в динамическом Лиспе.
Рассмотрим следующий пример:

<a id="indexC:map"></a>
```scheme
(define (map fn l)  ; или `mapcar`, как кому нравится
  (if (pair? l)
      (cons (fn (car l)) (map fn (cdr l)))
      '() ) )

(let ((l '(a b c)))
  (map (lambda (x) (list-ref l x))
       '(2 1 0)))
```

(Функция `(list-ref $\ell$ *n*)` возвращает *n*‑й элемент
списка $\ell$.)

В Scheme мы бы получили `(c b a)`, но в динамическом Лиспе результатом будет
`(0 0 0)`! Причина: свободная переменная `l` в функции \ic{(lambda (x)
(list-ref l x))}, имя которой уже занято локальной переменной `l`
в `map`.

Это затруднение можно решить, просто изменив конфликтующие имена.
Например,
достаточно будет переименовать какую-нибудь из двух `l`.
Например, ту,
которая внутри `map`, потому что это более разумно.
Но какое имя выбрать,
чтобы эта проблема не возникла снова? Если приписывать спереди к имени каждой
переменной номер паспорта программиста, а сзади — текущее \UNIX-время, то
это, конечно, значительно снизит вероятность коллизий, но читабельность программ
будет оставлять желать лучшего.

В начале восьмидесятых годов сложилась довольно неприятная ситуация: студентов
учили Лиспу на примере интерпретаторов, но их понимание областей видимости
отличалось от понимания компиляторов.
В 1975 году Scheme [[ss75]](zz_bibliography.html#ss75) показал,
что интерпретатор и компилятор возможно примирить, поместив обоих в мир, где все
переменные лексические.
{\CommonLisp} забил последний гвоздь в гроб этой
проблемы, постановив, что *хорошее* понимание — это понимание
компилятора, а для него удобнее лексические переменные.
Интерпретатор должен
был подчиниться новым правилам.
Растущий успех Scheme и других функциональных
языков, вроде ML и компании, популяризовал новый подход сначала в языках
программирования, а затем и в умах людей.


\subsection{Дальнее и ближнее связывание}<!--  -->
\label{basics/representing-functions/ssect:deep-or-shallow}

<a id="indexR:дальнее (deep) связывание"></a>
<a id="indexR:связывание!дальнее (deep)"></a>
<a id="indexC:lookup!стоимость"></a>
Но не всё так просто заканчивается.
Разработчики языков нашли способы ускорить
поиск значений динамических переменных.
Если окружения представлены
ассоциативными списками, то время на поиск значения переменной (стоимость вызова
`lookup`) линейно зависит от длины списка.\footnote*{К счастью, статистика
показывает, что переменные, располагающиеся ближе к началу списка, используются
чаще тех, что находятся глубоко внутри.
Кстати, ещё стоит отметить, что
лексические окружения в среднем меньше по размеру, чем динамические, так как
последним необходимо хранить все переменные, участвующие в вычислениях, включая
одноимённые [[bak92a]](zz_bibliography.html#bak92a).} Такой подход называется _глубоким_ или
_дальним связыванием_ (deep binding), так как значения динамических
переменных обычно располагаются на некотором удалении от текущего локального
окружения.

<a id="indexR:ближнее (shallow) связывание"></a>
<a id="indexR:связывание!ближнее (shallow)"></a>
<a id="indexE:Cval"></a>
Существует и другой метод, называемый _поверхностным_ или \term{ближним
связыванием} (shallow binding).
Суть его в том, что переменная напрямую связана
с местом, где хранится её значение в текущий момент, без привязки к окружению.
Проще всего это реализовать, положив это значение в специальное поле символа,
соответствующего этой переменной; это поле называют `Cval` или \term{ячейкой
значения} (value cell).
В таком случае стоимость `lookup` постоянна или около
того: требуется лишь одна косвенная адресация и, может быть, сдвиг.
Так как
бесплатный сыр бывает только в мышеловке, то стоит отметить, что вызов функции
при использовании этого метода выходит дороже, потому что требуется сначала
где‑то сохранить старые значения аргументов, затем записать новые значения
в поля соответствующих символов.
А потом, что самое важное, после выхода из
функции старые значения в символах необходимо восстановить обратно, а это может
помешать оптимизации хвостовой рекурсии.
(Хотя есть варианты: [[sj93]](zz_bibliography.html#sj93).)

Изменив структуру окружений, мы сможем частично проэмулировать\footnote{Здесь мы
не реализуем присваивание переменным, захваченным замыканиями.
Об этом можно
почитать в [[bcsj86]](zz_bibliography.html#bcsj86).} ближнее связывание.
Но с оговорками: список
аргументов не может быть точечным (так будет легче его разбирать) и мы не будем
проверять арность функций.
Новые функции будем обозначать префиксом `s.`,
чтобы не путать их с другими.

<a id="indexC:s.make-function"></a>
<a id="indexC:s.lookup"></a>
<a id="indexC:s.update"!"></a>
```scheme
(define (s.make-function variables body env)
  (lambda (values current.env)
    (let ((old-bindings
           (map (lambda (var val)
                  (let ((old-value (getprop var 'apval)))
                    (putprop var 'apval val)
                    (cons var old-value) ) )
                variables
                values ) ))
      (let ((result (eprogn body current.env)))
        (for-each (lambda (b) (putprop (car b) 'apval (cdr b)))
                  old-bindings )
        result ) ) ) )

(define (s.lookup id env)
  (getprop id 'apval) )

(define (s.update! id env value)
  (putprop id 'apval value) )
```

<a id="indexC:putprop"></a><a id="indexC:getprop"></a>
В Scheme функции `putprop` и `getprop` не входят в стандарт, так как здесь
не любят неэффективные глобальные побочные эффекты, но тем не менее, даже
в [[as85]](zz_bibliography.html#as85) есть аналогичные `put` и `get`.
\seeEx[lisp1-2-omega/ex:write-put/get-prop]

<a id="indexR:списки свойств"></a>
<a id="indexR:символы!списки свойств"></a>
<a id="indexE:P-список"></a>
<a id="indexR:хеш-таблицы"></a>
С помощью этих функций мы эмулируем наличие у символов поля,\footnote*{Это поле
названо в честь `apval` из \cite{mae+62}.
\seePage[lisp1-2-omega/par:apval]
Тогда значения полей действительно хранились в наивных P‑списках.} где хранится
значение одноимённой переменной.
Независимо от их настоящей реализации,<!--  -->
\footnote*{Эти функции проходят по списку свойств символа (его P‑списку,
от property) до тех пор, пока не найдут нужное.
Скорость поиска, соответственно,
линейно зависит от длины списка, если только не применяются хеш-таблицы.} будем
считать, что они выполняются за постоянное время.

Заметьте, что в этой реализации абсолютно не используется окружение определения
`env`.
Поэтому для поддержки замыканий нам потребуется изменить реализацию
`make-closure`, так как она теперь не имеет доступа к окружению определения
(ввиду его отсутствия).
При создании замыкания необходимо просмотреть тело
функции, выделить все свободные переменные и правильно их сохранить внутри
замыкания.
Мы реализуем это позже.

<a id="indexE:rerooting"></a>
Дальнее связывание облегчает смену окружений и многозадачность, теряя в скорости
поиска переменных.
Ближнее связывание ускоряет поиск переменных, но теряет
в скорости вызова функций.
Генри Бейкеру [[bak78]](zz_bibliography.html#bak78) удалось объединить эти два
подхода в технику под названием _rerooting_.

Наконец, не забывайте, что ближнее и дальнее связывание — это лишь способы
реализации, они никак не влияют на само понятие связывания.


<a id="basics/sect:global-environment"></a>
## Глобальное окружение

<a id="indexR:библиотека!функций"></a>
<a id="indexR:Лисп!примитивы"></a>
Пустое глобальное окружение — это печально, поэтому большинство лисп-систем
предоставляют *библиотеки* функций.
Например, в глобальном окружении
{\CommonLisp} (CLtL1) около 700 функций, у {\LeLisp} их более 1500,
у {\ZetaLisp} — более 10\,000.
Без библиотек Лисп был бы лишь прикладным
$\lambda$-исчислением, в котором нельзя даже распечатать полученные результаты.
Библиотеки очень важны для конечного пользователя.
Специальные формы — это
строительные кирпичики для разработчиков интерпретаторов, но для конечного
пользователя такими кирпичиками являются функции библиотек.
По‑видимому, именно
отсутствие в чистом Лиспе таких банальных вещей вроде библиотеки
тригонометрических функций прочно укоренило мысль о непригодности Лиспа для
«серьёзных программ».
Как говорится в [[sla61]](zz_bibliography.html#sla61), возможность символьного
интегрирования или дифференцирования — это, конечно, замечательно, но кому
нужен язык, где нет даже синуса или тангенса?

Мы ожидаем, что все привычные функции вроде `cons`, `car` {\itp} будут
доступны в глобальном окружении.
Также можно туда поместить несколько простых
констант вроде логических значений и пустого списка.

Для этого мы определим пару макросов.
Исключительно для удобства, потому что мы
о них ещё даже не говорили.\footnote*{Согласитесь, было бы странным втискивать
всю книгу в первую главу.} Макросы — это довольно сложная и важная вещь сами
по себе, так что им посвящена собственная глава.
\seePage[chapter:macros]

Эти два макроса облегчат наполнение глобального окружения.
Само глобальное
окружение является расширением начального окружения `env.init`.

\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}

<a id="indexC:env.global"></a>
<a id="indexC:definitial"></a>
<a id="indexC:defprimitive"></a>
```scheme
(define env.global env.init)
|\ForLayout{display}{\vskip-0.4\baselineskip}|
(define-syntax definitial
  (syntax-rules ()
    ((definitial name)
     (begin (set! env.global (cons (cons 'name 'void) env.global))
            'name ) )
    ((definitial name value)
     (begin (set! env.global (cons (cons 'name value) env.global))
            'name ) ) ) )
|\ForLayout{display}{\vskip-0.4\baselineskip}|
(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value arity)
     (definitial name
        (lambda (values)
          (if (= arity (length values))
              (apply value values)      ; Родная `apply` Scheme
              (wrong "Incorrect arity" (list 'name values)|\:|)|\:|)|\:|)|\:|)|\:|)|\:|)|\:|)
```

<a id="indexC:the-false-value"></a>
Несмотря на то, что стандарт Scheme этого не требует, мы определим несколько
полезных констант.
Заметим, что `t` — это переменная в определяемом Лиспе,
а `\#t` — это значение из определяющего Лиспа.
Оно подходит, так как любое
значение, не совпадающее с `the-false-value`, является _истиной_.

```scheme
(definitial t #t)
(definitial f the-false-value)
(definitial nil '())
```

\ForLayout{display}{\endgroup}

<a id="indexR:синтаксис!для \protect`\#t` и `\#f`"></a>
<a id="indexR:логические значения"></a>
Хотя это удобно — иметь глобальные переменные с настоящими объектами для
данных сущностей, но есть и другое решение: особый синтаксис.
Scheme использует
`\#t` и `\#f`, подставляя вместо них логические _истину_ и
_ложь_.
В этом есть определённый смысл:

\begin{enumerate}
  \item Они всегда видимы: `\#t` означает _истину_ в любом
        контексте, даже тогда, когда локальная переменная
        названа `t`.

  \item Значение `\#t` невозможно изменить, но многие интерпретаторы
        позволят изменить значение глобальной переменной `t`.
\end{enumerate}

Например, выражение `(if t 1 2)` вернёт `2`, если оно вычисляется
в следующем окружении: `(let ((t \#f)) (if t 1 2))`.

<a id="indexC:eq?"></a>
Существует много способов ввести такой синтаксис.
Наиболее простой способ —
это вшить значения `t` и `f` в вычислитель:

```scheme
(define (evaluate e env)
  (if (atom? e)
      (cond ((eq? e 't) #t)
            ((eq? e 'f) #f)
            ...
            ((symbol? e) (lookup e env))
            ...
            (else (wrong "Cannot evaluate" exp)) )
      ...
) )
```

<a id="indexR:инлайнинг!функций"></a>
<a id="indexR:встраивание!функций"></a>
<a id="indexR:функции!встраиваемые"></a>
<a id="indexR:связывание!изменяемое"></a>
<a id="indexR:связывание!неизменяемое"></a>
Также мы могли бы ввести понятия _изменяемого_ и _неизменяемого_
связывания.
Неизменяемые переменные отвергаются присваиванием.
Ничто и никогда
не сможет изменить значение неизменяемой переменной.
Такая концепция существует,
хоть и не всегда явно, во многих системах.
Например, существуют так называемые
_инлайн-функции_ (также известные как _подставляемые_ или
_встраиваемые_), вызов которых можно полностью заменить прямой подстановкой
их тела.
\seePage[fast/fast/integrating/par:inlining]

Чтобы можно было спокойно подставить вместо `(car x)` код функции,
возвращающей левый элемент точечной пары `x`, необходимо быть абсолютно
уверенным в том, что значение глобальной переменной `car` никогда не менялось
и не поменяется в будущем.
Посмотрите, какая беда случается, если это не так:

```scheme
(set! my-global (cons 'c 'd))
   |\is| (c .
d)
(set! my-test (lambda () (car my-global)))
   |\is| #<MY-TEST procedure>
(begin (set! car cdr)
       (set! my-global (cons 'a 'b))
       (my-test) )
   |\is| |*?????*|
```

К счастью, в результате может получиться только `a` или `b`.
Если
`my-test` использует значение `car` на момент определения, то мы
получим `a`.
Если же `my-test` будет использовать текущее
значение `car`, то ответом будет `b`.
Полезным будет также сравнить в этом
аспекте `my-test` и `my-global`: обычно первый вариант поведения ожидается
от `my-test` при использовании компилятора, тогда как для `my-global`
нормальным считается именно второй вариант.
\seePage[lisp1-2-omega/recusion/simple/code:redefine]

<a id="indexC:foo"></a><a id="indexC:bar"></a><a id="indexC:fib"></a><a id="indexC:fact"></a>
Также мы добавим несколько рабочих переменных\footnote{К сожалению, сейчас они
ещё и инициализируются.
Эта ошибка будет исправлена позже.} в глобальное
окружение, так как сейчас у нас нет способа динамически создавать переменные.
По статистике, предлагаемые имена составляют приблизительно {96,037\,\<!-- } -->
используемых при тестировании свеженаписанных интерпретаторов.

<!-- \ForLayout{display}{\begingroup -->
<!-- \lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}} -->

```scheme
(definitial foo)
(definitial bar)
(definitial fib)
(definitial fact)
```

<!-- \ForLayout{display}{\endgroup} -->

Наконец, определим несколько примитивных функций (не все, потому что такие
полные списки — это хорошее снотворное).
Главная сложность состоит
в соединении механизмов вызова функций определяемого и определяющего языков.
Зная, что аргументы собираются нашим интерпретатором в список, достаточно просто
применить
к нему `apply`.\footnote*{Можно только порадоваться за наш выбор не называть
`invoke` «`apply`».} Заметьте, что арность функций будет соблюдаться,
так как мы включили проверку в определение макроса `defprimitive`.

```scheme
(defprimitive cons cons 2)
(defprimitive car car 1)
(defprimitive set-cdr! set-cdr! 2)
(defprimitive + + 2)
(defprimitive eq? eq? 2)
(defprimitive < < 2)
```


<a id="basics/sect:starting-the-interpreter"></a>
## Запускаем интерпретатор

Нам осталось показать только одну вещь: дверь в наш новый мир.

<a id="indexC:chapter1-scheme"></a>
```scheme
(define (chapter1-scheme)
  (define (toplevel)
    (display (evaluate (read) env.global))
    (toplevel) )
  (toplevel) )
```

Поскольку наш интерпретатор ещё мал и неопытен, но подаёт большие надежды,
предлагаем вам в качестве упражнения написать функцию, позволяющую из него
выйти.


<a id="basics/sect:conclusions"></a>
## Заключение

<a id="indexR:язык!и смысл программ"></a>
Действительно ли мы сейчас определили язык?

<a id="indexR:смысл программ"></a>
<a id="indexR:программы!смысл"></a>
Нет никаких сомнений в том, что мы можем запустить `evaluate`, передать ей
выражение, и она вскоре вернёт результат вычислений.
Но сама функция
`evaluate` не имеет никакого смысла без языка своего определения, а если
у нас нет определения языка определения, то мы вообще ни в чём не можем
быть уверены.
Так как каждый лиспер является дальним родственником барона
Мюнхгаузена, то, наверное, будет достаточно взять в качестве языка определения
тот, который мы только что определили.
Следовательно, у нас есть язык $L$,
определённый функцией `evaluate`, написанной на языке $L$.
Такой язык
является решением следующего уравнения относительно $L$:
<!--  -->
\begin{equation*}
  \forall\pi \in \Vset{Программы}\colon
    L\text{`(evaluate (quote $\pi$) env.global)`} \equiv L\pi
\end{equation*}

Исполнение любой программы $\pi$, написанной на $L$ (обозначается как $L\pi$),
должно вести себя так же (то есть давать тот же результат или никогда
не завершаться), как и выражение `(evaluate (quote $\pi$) env.global)` на
том же языке $L$.
Одним из занимательных следствий этого утверждения является
то, что `evaluate` способна\footnote{После того, как мы раскроем все
используемые макросы и сокращения вроде `let`, `case`, `define`
{\itd} Потом надо будет ещё поместить в глобальное окружение функции
`evaluate`, `evlis` и др.} проинтерпретировать сама себя.
Следовательно,
следующие выражения эквивалентны:

```scheme
(evaluate (quote |$\pi$|) env.global) |\eq|
  |\eq| (evaluate (quote (evaluate (quote |$\pi$|) env.global)) env.global)
```

Есть ли ещё решения приведённого уравнения? Да, и их великое множество! Как мы
видели раньше, определение `evaluate` вовсе не обязательно указывает порядок
вычислений.
Множество других свойств языка, используемого для определения,
бессознательно *наследуются* определяемым языком.
Мы, по сути, ничего
не можем о них сказать, но все эти варианты претендуют на решение указанного
уравнения.
Вместе с многочисленными тривиальными решениями.
Рассмотрим,
к примеру, язык $L_{2001}$, любая программа на котором возвращает $2001$.
Даже
такой язык удовлетворяет этому уравнению.
Поэтому для определения настоящих
языков необходимы другие методы, их мы рассмотрим в следующих главах.


<a id="basics/sect:exercises"></a>
## Упражнения

\begin{exercise}\label{basics/ex:tracer}
<a id="indexR:трассировка"></a>
Модифицируйте функцию `evaluate` так, чтобы она стала трассировщиком.
Все
вызовы функций должны выводить на экран фактические аргументы и возвращаемый
результат.
Легко представить себе дальнейшее развитие этого инструмента
в пошаговый отладчик, вдобавок позволяющий изменять порядок выполнения
отлаживаемой программы.
\end{exercise}

\begin{exercise}\label{basics/ex:excess-recursion}
Если функции `evlis` передаётся список из одного выражения, она делает
один лишний рекурсивный вызов.
Придумайте способ, как избавиться от него.
\end{exercise}

\begin{exercise}\label{basics/ex:new-extend}
Предположим, новая функция `extend` определена так:

<a id="indexC:extend"></a>
```scheme
(define (extend env names values)
  (cons (cons names values) env) )
```

Определите соответствующие функции `lookup` и `update!`.
Сравните их
с ранее рассмотренными.
\end{exercise}

\begin{exercise}\label{basics/ex:racks}
<a id="indexR:ближнее (shallow) связывание"></a>
<a id="indexR:связывание!ближнее (shallow)"></a>
<a id="indexE:rack"></a>
В работе [[ss80]](zz_bibliography.html#ss80) предлагается другой механизм ближнего связывания, названный
_rack_.
Символ связывается с полем, хранящим не единственное значение, а
стек значений.
В каждый момент времени значением переменной является находящаяся
на вершине стека величина.
Перепишите функции `s.make-function`,
`s.lookup` и `s.update!` для реализации этой идеи.
\end{exercise}

\begin{exercise}\label{basics/ex:liar-liar!}
<a id="indexR:представление!логических значений"></a>
Если вы ещё не заметили, то в определение функции `<` вкралась ошибка! Ведь
эта функция должна возвращать логические значения определяемого языка, а
не определяющего.
Исправьте это досадное недоразумение.
\end{exercise}

\begin{exercise}\label{basics/ex:def-list}
Определите функцию `list`.
\end{exercise}

\begin{exercise}\label{basics/ex:def-call/cc}
Для обожающих продолжения: определите `call/cc`.
\end{exercise}

\begin{exercise}\label{basics/ex:def-apply}
Определите функцию `apply`.
\end{exercise}

\begin{exercise}\label{basics/ex:def-end}
Определите функцию `end`, позволяющую выйти из интерпретатора, разработанного
в этой главе.
\end{exercise}

\begin{exercise}\label{basics/ex:slowpoke}
<a id="indexR:уровни интерпретации"></a>
<a id="indexR:интерпретация!уровневая"></a>
Сравните скорость Scheme и `evaluate`.
Затем сравните скорость `evaluate`
и `evaluate`, интерпретируемой с помощью `evaluate`.
\end{exercise}

\begin{exercise}\label{basics/ex:no-gensym}
Ранее мы смогли успешно определить `begin` через `lambda`
\seePage[basics/forms/sequence/par:gensym-puzzle], но для этого нам
потребовалось использовать функцию `gensym`, чтобы избежать коллизий имён
переменных.
Переопределите `begin` в таком же духе, но без использования
`gensym`.
\end{exercise}


\section*{Рекомендуемая литература}

Все работы по интерпретаторам, приведённые в начале этой главы, являются
довольно интересными, но если вы не можете столько читать, то вот наиболее
стоящие из них:
\begin{itemize}
  \item среди «$\lambda$‑papers»: [[ss78a]](zz_bibliography.html#ss78a);

  \item самая короткая в мире статья, которая содержит полный интерпретатор
        Лиспа: [[mcc78b]](zz_bibliography.html#mcc78b);

  \item «нестрого формальное» описание интерпретации: [[rey72]](zz_bibliography.html#rey72);

  \item местная книга Бытия: \cite{mae+62}.
\end{itemize}
